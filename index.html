<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plataforma de Backtest Multi-Mercado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .step-card {
            transition: all 0.3s ease-in-out; opacity: 0.5; pointer-events: none;
            transform: translateY(10px); display: none;
        }
        .step-card.active, .step-card.done { display: block; }
        .step-card.active { opacity: 1; pointer-events: auto; transform: translateY(0); }
        .step-card.done { opacity: 0.7; transform: translateY(0); border-left-color: #22c55e; }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 24px; height: 24px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .chart-container { position: relative; height: 500px; width: 100%; }
        .data-table-container { max-height: 500px; overflow-y: auto; }
        [contenteditable]:focus { outline: 2px solid #3b82f6; background-color: #374151; }
        .gemini-btn {
            background-color: #4f46e5; color: white;
            transition: background-color 0.3s;
        }
        .gemini-btn:hover { background-color: #4338ca; }
        .prose { color: #d1d5db; }
        .prose h3 { color: #6ee7b7; }
        .prose h4 { color: #5eead4; }
        .prose strong { color: #f0fdf4; }
        .prose ul > li::before { background-color: #6ee7b7; }
        .probability-table-container { max-height: 600px; overflow-y: auto; }
        .page-tab { transition: all 0.2s ease-in-out; }
        .page-tab.active { background-color: #4f46e5; color: white; }
    </style>
</head>
<body class="bg-gray-900 text-white p-4 sm:p-6 md:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 id="mainTitle" class="text-3xl sm:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Backtest de Média Móvel</h1>
            <p class="text-gray-400 mt-2">Plataforma de backtest multi-mercado com análise e simulação por IA.</p>
        </header>

        <!-- NAVEGAÇÃO POR PÁGINAS/ATIVOS -->
        <nav class="mb-8 p-2 bg-gray-800 rounded-lg shadow-md">
            <div id="pageTabs" class="flex flex-wrap items-center justify-center gap-2">
                <!-- As abas serão geradas aqui pelo JS -->
            </div>
        </nav>

        <div class="relative">
            <!-- BOTÃO DE RECOMEÇAR -->
            <button id="resetPageBtn" title="Limpar todos os dados e recomeçar a análise para este ativo." class="absolute top-0 right-0 z-10 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg inline-flex items-center transition">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                <span>Recomeçar Análise</span>
            </button>
            <div id="mainContent" class="space-y-8">
            <!-- Etapa 1: Carregar Arquivo -->
            <div id="step1" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-blue-500 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">1</div>
                    <h2 class="text-2xl font-semibold ml-4">Fonte de Dados</h2>
                </div>
                <p class="text-gray-400 mb-4">Inicie carregando um novo arquivo CSV para este ativo.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div id="uploadArea" class="flex-1">
                        <input type="file" id="csvFile" accept=".csv" class="hidden">
                        <label for="csvFile" class="w-full h-full cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg inline-flex items-center justify-center transition">
                            <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                            <span>Carregar Novo CSV</span>
                        </label>
                    </div>
                </div>
                <div id="fileStatus" class="mt-4 text-gray-300 hidden"></div>
                <div id="step1Error" class="mt-4 text-red-400 hidden p-3 bg-red-900/50 rounded-lg"></div>
            </div>

            <!-- Etapa 1.5: Confirmar Separador -->
            <div id="separatorStep" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-gray-600 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-gray-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">1.5</div>
                    <h2 class="text-2xl font-semibold ml-4">Confirmar Separador de Coluna</h2>
                </div>
                <p class="text-gray-400 mb-4">Escolha o separador para que os dados na tabela abaixo fiquem corretamente divididos em colunas.</p>
                <div id="delimiterOptions" class="flex flex-wrap gap-x-6 gap-y-2 items-center mb-4">
                    <label class="flex items-center space-x-2 text-white cursor-pointer">
                        <input type="radio" name="delimiter" value="," class="form-radio bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-500">
                        <span>Vírgula ( , )</span>
                    </label>
                    <label class="flex items-center space-x-2 text-white cursor-pointer">
                        <input type="radio" name="delimiter" value=";" class="form-radio bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-500">
                        <span>Ponto e vírgula ( ; )</span>
                    </label>
                </div>
                <p class="text-gray-400 mb-2 font-semibold">Pré-visualização dos Dados:</p>
                <div id="dataParsePreview" class="bg-gray-900 p-2 rounded-md overflow-x-auto"></div>
                <button id="confirmSeparatorBtn" class="mt-6 w-full md:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg transition">
                    Confirmar Separador e Continuar
                </button>
            </div>

            <!-- Etapa 2: Mapear Colunas -->
            <div id="step2" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-gray-600 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-gray-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">2</div>
                    <h2 class="text-2xl font-semibold ml-4">Mapear Colunas</h2>
                </div>
                <p class="text-gray-400 mb-6">Associe as colunas detetadas com os campos necessários. <strong class="text-gray-200">Data, Abertura, Máxima, Mínima, e Fechamento</strong> são necessários para o gráfico de candlestick.</p>
                <div id="mappingUI" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4"></div>
                <div id="step2Error" class="mt-4 text-red-400 hidden p-3 bg-red-900/50 rounded-lg"></div>
                <button id="confirmMappingBtn" class="mt-6 w-full md:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg transition">
                    Confirmar Mapeamento e Validar
                </button>
            </div>

            <!-- Etapa 3: Planilha de Dados e Execução -->
            <div id="step3" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-gray-600 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-gray-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">3</div>
                    <h2 class="text-2xl font-semibold ml-4">Configuração e Execução</h2>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <label for="smaPeriod" class="block mb-2 text-sm font-medium text-gray-300">Período da Média Móvel (para Backtest Simples)</label>
                        <div class="flex items-center gap-2">
                           <input type="number" id="smaPeriod" value="21" min="2" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        </div>
                    </div>
                    <div>
                        <label for="contractSize" id="contractSizeLabel" class="block mb-2 text-sm font-medium text-gray-300">Tamanho do Contrato</label>
                        <input type="number" id="contractSize" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5" readonly>
                    </div>
                </div>

                <div class="flex flex-wrap gap-4 mb-4">
                    <button id="addNewRowBtn" title="Adicionar uma nova linha de dados no final da tabela" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg inline-flex items-center transition">
                         <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        Adicionar Nova Linha
                    </button>
                </div>
                <div id="statusMessage" class="mb-4"></div>
                <h3 class="font-semibold text-lg mb-2 text-gray-300">Dados para o Backtest (Editável)</h3>
                <div class="data-table-container rounded-lg border border-gray-700">
                    <table id="dataPreview" class="min-w-full text-sm text-left text-gray-300 bg-gray-800"></table>
                </div>
                <button id="runBacktestBtn" class="mt-8 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg transition text-lg">
                    Rodar Backtest Simples
                </button>
            </div>
            </div>
        </div>
        
        <div id="analysisContent">
        <!-- Seção de Resultados -->
        <div id="resultsSection" class="hidden mt-12">
            <h2 id="resultsTitle" class="text-3xl font-bold text-center mb-8 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Resultados do Backtest</h2>
            <div class="bg-gray-800 p-4 sm:p-6 rounded-lg shadow-lg mb-8">
                <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Gráfico Interativo de Preços e Sinais</h3>
                <div class="chart-container"><canvas id="priceChart"></canvas></div>
            </div>
            <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                <div id="statsSection" class="bg-gray-800 p-4 sm:p-6 rounded-lg shadow-lg">
                    <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Estatísticas Principais</h3>
                    <div id="statsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
                </div>
                <div class="bg-gray-800 p-4 sm:p-6 rounded-lg shadow-lg">
                    <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Curva de Património</h3>
                    <div class="chart-container" style="height: 400px"><canvas id="equityChart"></canvas></div>
                </div>
            </div>
        </div>

        <!-- SEÇÃO WALK-FORWARD -->
        <div id="wfaSection" class="hidden mt-12">
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-3xl font-bold text-center mb-2 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500">Análise Preditiva: Walk-Forward</h2>
                <p class="text-gray-400 text-center mb-8">Teste a robustez da sua estratégia simulando uma otimização contínua ao longo do tempo. Isso mede a capacidade de adaptação da estratégia a novas condições de mercado.</p>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6 max-w-2xl mx-auto">
                    <div>
                        <label for="wfaOptimizationPeriods" class="block mb-2 text-sm font-medium text-gray-300">Período de Otimização (dias)</label>
                        <input type="number" id="wfaOptimizationPeriods" value="120" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-purple-500 focus:border-purple-500 block w-full p-2.5">
                    </div>
                    <div>
                        <label for="wfaTestPeriods" class="block mb-2 text-sm font-medium text-gray-300">Período de Teste (dias)</label>
                        <input type="number" id="wfaTestPeriods" value="30" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-purple-500 focus:border-purple-500 block w-full p-2.5">
                    </div>
                </div>
                <div id="wfaError" class="mt-4 mb-4 text-red-400 hidden p-3 bg-red-900/50 rounded-lg text-center"></div>
                <div class="text-center">
                    <button id="runWfaBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg transition text-lg">
                        Iniciar Análise Walk-Forward
                    </button>
                </div>

                <div id="wfaStatus" class="mt-6 text-center"></div>
                
                <div id="wfaResultsContainer" class="hidden mt-8">
                        <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                            <div class="bg-gray-900/50 p-4 sm:p-6 rounded-lg shadow-lg">
                                <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Estatísticas Walk-Forward</h3>
                                <div id="wfaStatsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
                            </div>
                            <div class="bg-gray-900/50 p-4 sm:p-6 rounded-lg shadow-lg">
                                <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Curva de Património Walk-Forward</h3>
                                <div class="chart-container" style="height: 400px"><canvas id="wfaEquityChart"></canvas></div>
                            </div>
                        </div>
                    <div id="wfaExplanation" class="mt-8 prose max-w-none"></div>

                    <!-- FERRAMENTA DE AÇÃO -->
                    <div id="currentParameterSection" class="hidden mt-10 pt-6 border-t border-gray-700 text-center">
                        <h3 class="font-semibold text-xl mb-4 text-center text-gray-200">Qual Parâmetro Usar Agora?</h3>
                        <p class="text-gray-400 mb-6">Com base no seu método validado, clique abaixo para encontrar o período de média móvel ideal, calculado com os dados mais recentes.</p>
                        <button id="runCurrentOptimizerBtn" class="gemini-btn font-bold py-3 px-6 rounded-lg inline-flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 0v6m0-6l-6 6M5 12a7 7 0 1114 0 7 7 0 01-14 0z"></path></svg>
                            Descobrir Melhor Parâmetro para Hoje
                        </button>
                         <div id="currentParameterError" class="mt-4 text-red-400 hidden p-3 bg-red-900/50 rounded-lg max-w-md mx-auto"></div>
                        <div id="currentParameterResult" class="mt-6 text-2xl hidden">
                            <p class="text-gray-400 text-base">O período otimizado para operar nos próximos <span id="paramTestDays" class="font-bold text-white"></span> dias é:</p>
                            <p id="optimizedPeriod" class="font-bold text-green-400 text-6xl my-2"></p>
                            <p class="text-gray-500 text-sm">(Calculado com os últimos <span id="paramOptimizationDays" class="font-bold text-gray-400"></span> dias de dados)</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SEÇÃO MONTE CARLO -->
        <div id="monteCarloSection" class="hidden mt-12">
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-3xl font-bold text-center mb-2 text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-cyan-500">Projeção de Risco e Probabilidade: Simulação de Monte Carlo</h2>
                <p class="text-gray-400 text-center mb-8">Gere milhares de futuros possíveis com base no "DNA" da sua estratégia (os resultados do Walk-Forward) para entender a faixa provável de resultados e riscos.</p>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6 max-w-2xl mx-auto">
                    <div>
                        <label for="mcSimulations" class="block mb-2 text-sm font-medium text-gray-300">Número de Simulações</label>
                        <input type="number" id="mcSimulations" value="2000" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                    </div>
                    <div>
                        <label for="mcProjectionDays" class="block mb-2 text-sm font-medium text-gray-300">Período de Projeção (dias)</label>
                        <input type="number" id="mcProjectionDays" value="252" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                    </div>
                </div>
                <div class="text-center">
                    <button id="runMcBtn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-8 rounded-lg transition text-lg">
                        Executar Simulação de Monte Carlo
                    </button>
                </div>

                <div id="mcStatus" class="mt-6 text-center"></div>
                
                <div id="mcResultsContainer" class="hidden mt-8">
                        <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                            <div class="bg-gray-900/50 p-4 sm:p-6 rounded-lg shadow-lg">
                                <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Probabilidades Futuras</h3>
                                <div id="mcStatsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
                            </div>
                            <div class="bg-gray-900/50 p-4 sm:p-6 rounded-lg shadow-lg">
                                <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Cone de Probabilidade de Património</h3>
                                <div class="chart-container" style="height: 400px"><canvas id="mcChart"></canvas></div>
                            </div>
                        </div>
                    <div id="mcExplanation" class="mt-8 prose max-w-none"></div>
                </div>
            </div>
        </div>

        <!-- NOVA SEÇÃO: MAPA DE PROBABILIDADES -->
        <div id="probabilityMapSection" class="hidden mt-12">
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                <h2 class="text-3xl font-bold text-center mb-2 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500">Análise Profunda: Mapa de Probabilidades por Estratégia</h2>
                <p class="text-gray-400 text-center mb-8">Compare o potencial estatístico de cada período de média móvel individualmente. Este estudo intensivo analisa o "DNA" de cada estratégia para projetar as suas probabilidades de sucesso em diferentes horizontes de tempo.</p>
                
                <div class="text-center">
                    <button id="runProbabilityMapBtn" class="bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-3 px-8 rounded-lg transition text-lg">
                        Gerar Mapa de Probabilidades
                    </button>
                </div>

                <div id="probabilityMapStatus" class="mt-6 text-center"></div>
                
                <div id="probabilityMapContainer" class="hidden mt-8">
                    <div class="probability-table-container rounded-lg border border-gray-700">
                        <table class="min-w-full text-sm text-left text-gray-300">
                            <thead id="probabilityMapThead" class="text-xs text-gray-200 uppercase bg-gray-600 sticky top-0"></thead>
                            <tbody id="probabilityMapTbody"></tbody>
                        </table>
                    </div>
                    <div id="probabilityMapExplanation" class="mt-8 prose max-w-none"></div>
                </div>
            </div>
        </div>
        </div>


    </div>

    <!-- MODAL PERSONALIZADO -->
    <div id="customModal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-700">
            <h3 id="modalTitle" class="text-xl font-bold mb-4 text-white"></h3>
            <p id="modalMessage" class="text-gray-300 mb-6"></p>
            <div id="modalActions" class="flex justify-end gap-4">
                <!-- Botões serão injetados aqui pelo JS -->
            </div>
        </div>
    </div>

    <script type="module">
        // escopo global para estado da aplicação, gráficos e arquivo atual
        let appState = {};
        let activePageKey = 'bgi';
        let priceChart = null, equityChart = null, wfaEquityChart = null, mcChart = null, currentFile = null;
        
        // Definição dos mercados disponíveis na plataforma
        const markets = {
            bgi: { name: 'Boi Gordo', code: 'BGI', contractSize: 330, unit: '@', currency: 'BRL' },
            ccm: { name: 'Milho', code: 'CCM', contractSize: 450, unit: 'sacas', currency: 'BRL' },
            sjc: { name: 'Soja', code: 'SJC', contractSize: 450, unit: 'sacas', currency: 'USD' },
            dol: { name: 'Dólar Cheio', code: 'DOL', contractSize: 50000, unit: 'US$', currency: 'BRL' },
            wdo: { name: 'Mini Dólar', code: 'WDO', contractSize: 10000, unit: 'US$', currency: 'BRL' },
            icf: { name: 'Café Arábica', code: 'ICF', contractSize: 100, unit: 'sacas', currency: 'USD' }
        };

        // Mapeamento dos elementos da UI para fácil acesso
        const ui = {
            mainTitle: document.getElementById('mainTitle'),
            pageTabs: document.getElementById('pageTabs'),
            resetPageBtn: document.getElementById('resetPageBtn'),
            step1: document.getElementById('step1'), 
            step2: document.getElementById('step2'), 
            step3: document.getElementById('step3'),
            separatorStep: document.getElementById('separatorStep'), 
            csvFileInput: document.getElementById('csvFile'), 
            fileStatus: document.getElementById('fileStatus'), 
            step1Error: document.getElementById('step1Error'),
            delimiterOptions: document.getElementById('delimiterOptions'), 
            dataParsePreview: document.getElementById('dataParsePreview'), 
            confirmSeparatorBtn: document.getElementById('confirmSeparatorBtn'),
            mappingUI: document.getElementById('mappingUI'), 
            confirmMappingBtn: document.getElementById('confirmMappingBtn'), 
            step2Error: document.getElementById('step2Error'),
            contractSizeInput: document.getElementById('contractSize'),
            contractSizeLabel: document.getElementById('contractSizeLabel'),
            smaPeriodInput: document.getElementById('smaPeriod'),
            addNewRowBtn: document.getElementById('addNewRowBtn'),
            statusMessage: document.getElementById('statusMessage'),
            dataPreview: document.getElementById('dataPreview'), 
            runBacktestBtn: document.getElementById('runBacktestBtn'),
            resultsSection: document.getElementById('resultsSection'),
            resultsTitle: document.getElementById('resultsTitle'),
            statsContainer: document.getElementById('statsContainer'),
            wfaSection: document.getElementById('wfaSection'),
            runWfaBtn: document.getElementById('runWfaBtn'),
            wfaOptimizationPeriods: document.getElementById('wfaOptimizationPeriods'),
            wfaTestPeriods: document.getElementById('wfaTestPeriods'),
            wfaStatus: document.getElementById('wfaStatus'),
            wfaError: document.getElementById('wfaError'),
            wfaResultsContainer: document.getElementById('wfaResultsContainer'),
            wfaStatsContainer: document.getElementById('wfaStatsContainer'),
            wfaExplanation: document.getElementById('wfaExplanation'),
            currentParameterSection: document.getElementById('currentParameterSection'),
            runCurrentOptimizerBtn: document.getElementById('runCurrentOptimizerBtn'),
            currentParameterResult: document.getElementById('currentParameterResult'),
            currentParameterError: document.getElementById('currentParameterError'),
            optimizedPeriod: document.getElementById('optimizedPeriod'),
            paramTestDays: document.getElementById('paramTestDays'),
            paramOptimizationDays: document.getElementById('paramOptimizationDays'),
            monteCarloSection: document.getElementById('monteCarloSection'),
            runMcBtn: document.getElementById('runMcBtn'),
            mcSimulations: document.getElementById('mcSimulations'),
            mcProjectionDays: document.getElementById('mcProjectionDays'),
            mcStatus: document.getElementById('mcStatus'),
            mcResultsContainer: document.getElementById('mcResultsContainer'),
            mcStatsContainer: document.getElementById('mcStatsContainer'),
            mcExplanation: document.getElementById('mcExplanation'),
            probabilityMapSection: document.getElementById('probabilityMapSection'),
            runProbabilityMapBtn: document.getElementById('runProbabilityMapBtn'),
            probabilityMapStatus: document.getElementById('probabilityMapStatus'),
            probabilityMapContainer: document.getElementById('probabilityMapContainer'),
            probabilityMapThead: document.getElementById('probabilityMapThead'),
            probabilityMapTbody: document.getElementById('probabilityMapTbody'),
            probabilityMapExplanation: document.getElementById('probabilityMapExplanation'),
            // Modal elements
            customModal: document.getElementById('customModal'),
            modalTitle: document.getElementById('modalTitle'),
            modalMessage: document.getElementById('modalMessage'),
            modalActions: document.getElementById('modalActions'),
        };

        /**
         * Retorna o estado inicial para uma nova página/ativo.
         */
        function getInitialPageState() {
            return {
                step: 1,
                fileContentChunk: '',
                headers: [],
                rawData: [],
                mappedData: [],
                wfaTradeReturns: [],
                hasBacktestRun: false,
                hasWfaRun: false,
                hasMcRun: false,
                hasProbMapRun: false,
            };
        }
        
        // --- LÓGICA DO MODAL ---
        /**
         * Exibe um modal customizado.
         * @param {string} title - Título do modal.
         * @param {string} message - Mensagem do modal.
         * @param {Array<Object>} buttons - Array de objetos de botão. Ex: [{ text, class, callback }]
         */
        function showModal(title, message, buttons) {
            ui.modalTitle.textContent = title;
            ui.modalMessage.innerHTML = message; // Use innerHTML to allow for simple formatting
            ui.modalActions.innerHTML = ''; // Limpa botões antigos

            buttons.forEach(btnInfo => {
                const button = document.createElement('button');
                button.textContent = btnInfo.text;
                button.className = `font-bold py-2 px-4 rounded-lg transition ${btnInfo.class}`;
                button.onclick = btnInfo.callback;
                ui.modalActions.appendChild(button);
            });

            ui.customModal.classList.remove('hidden');
            ui.customModal.classList.add('flex');
        }

        /**
         * Oculta o modal customizado.
         */
        function hideModal() {
            ui.customModal.classList.add('hidden');
            ui.customModal.classList.remove('flex');
        }

        // --- GERENCIAMENTO DE ESTADO E PÁGINA ---

        function saveStateToLocalStorage() {
            localStorage.setItem('appState', JSON.stringify(appState));
            localStorage.setItem('activePageKey', activePageKey);
        }

        function loadStateFromLocalStorage() {
            const savedState = localStorage.getItem('appState');
            const savedPage = localStorage.getItem('activePageKey');
            if (savedState) {
                appState = JSON.parse(savedState);
                // Reconverte as strings de data para objetos Date
                Object.keys(appState).forEach(pageKey => {
                    if (appState[pageKey].mappedData) {
                        appState[pageKey].mappedData = appState[pageKey].mappedData.map(row => ({
                            ...row,
                            date: new Date(row.date)
                        }));
                    }
                });
            }
            if (savedPage && markets[savedPage]) {
                activePageKey = savedPage;
            }
        }

        function createPageTabs() {
            ui.pageTabs.innerHTML = '';
            Object.keys(markets).forEach(key => {
                if (!appState[key]) {
                    appState[key] = getInitialPageState();
                }
                const market = markets[key];
                const tab = document.createElement('button');
                tab.id = `tab-${key}`;
                tab.className = 'page-tab py-2 px-4 rounded-md font-semibold bg-gray-700 hover:bg-gray-600';
                tab.textContent = market.name;
                tab.addEventListener('click', () => switchPage(key));
                ui.pageTabs.appendChild(tab);
            });
        }

        function switchPage(pageKey) {
            activePageKey = pageKey;
            
            document.querySelectorAll('.page-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`tab-${pageKey}`).classList.add('active');

            const market = markets[pageKey];
            ui.mainTitle.textContent = `Backtest de Média Móvel - ${market.name}`;
            ui.contractSizeInput.value = market.contractSize;
            ui.contractSizeLabel.textContent = `Tamanho do Contrato (${market.unit})`;
            
            renderCurrentPage();
            saveStateToLocalStorage();
        }

        function renderCurrentPage() {
            const state = appState[activePageKey];
            
            // Oculta tudo primeiro
            const allSteps = [ui.step1, ui.separatorStep, ui.step2, ui.step3];
            allSteps.forEach(s => s.style.display = 'none');
            const allAnalysisSections = [ui.resultsSection, ui.wfaSection, ui.monteCarloSection, ui.probabilityMapSection];
            allAnalysisSections.forEach(s => s.classList.add('hidden'));

            // Mostra o card do passo atual
            const stepMap = { 1: ui.step1, 1.5: ui.separatorStep, 2: ui.step2, 3: ui.step3 };
            Object.values(stepMap).forEach(el => el.classList.remove('active', 'done'));

            if (stepMap[state.step]) {
                const currentStep = stepMap[state.step];
                currentStep.style.display = 'block';
                currentStep.classList.add('active');
                
                // Marca os passos anteriores como concluídos
                let i = 1;
                let stepsOrder = [1, 1.5, 2, 3];
                let currentIndex = stepsOrder.indexOf(state.step);

                for(let j=0; j < currentIndex; j++){
                    const stepKey = stepsOrder[j];
                    const stepEl = stepMap[stepKey];
                     if (stepEl) {
                        stepEl.style.display = 'block';
                        stepEl.classList.add('done');
                    }
                }
            }

            // Se os dados estiverem mapeados, renderiza a tabela na Etapa 3
            if(state.step === 3 && state.mappedData.length > 0) {
                renderEditableTable();
            }

            // Mostra as seções de análise se já foram executadas
            if (state.hasBacktestRun) {
                ui.resultsSection.classList.remove('hidden');
                ui.wfaSection.classList.remove('hidden');
            }
            if (state.hasWfaRun) {
                ui.wfaResultsContainer.classList.remove('hidden');
                ui.currentParameterSection.classList.remove('hidden');
                ui.monteCarloSection.classList.remove('hidden');
                ui.probabilityMapSection.classList.remove('hidden');
            }
            if (state.hasMcRun) {
                ui.mcResultsContainer.classList.remove('hidden');
            }
            if (state.hasProbMapRun) {
                ui.probabilityMapContainer.classList.remove('hidden');
            }
        }
        
        ui.resetPageBtn.addEventListener('click', () => {
            showModal(
                'Confirmar Recomeço',
                `Tem a certeza de que deseja apagar todos os dados e recomeçar a análise para <strong>${markets[activePageKey].name}</strong>? Esta ação não pode ser desfeita.`,
                [
                    { 
                        text: 'Cancelar', 
                        class: 'bg-gray-600 hover:bg-gray-500', 
                        callback: hideModal 
                    },
                    { 
                        text: 'Confirmar e Apagar', 
                        class: 'bg-red-600 hover:bg-red-700', 
                        callback: () => {
                            appState[activePageKey] = getInitialPageState();
                            // Destroi gráficos para limpar a memória
                            [priceChart, equityChart, wfaEquityChart, mcChart].forEach(chart => {
                                if(chart) chart.destroy();
                            });
                            priceChart = equityChart = wfaEquityChart = mcChart = null;
                            switchPage(activePageKey);
                            hideModal();
                        }
                    }
                ]
            );
        });

        // --- FLUXO DE CARREGAMENTO DE DADOS (ETAPAS 1-3) ---

        ui.csvFileInput.addEventListener('change', (event) => {
            currentFile = event.target.files[0];
            if (!currentFile) return;
            appState[activePageKey].fileContentChunk = '';
            showStatus('Lendo amostra do arquivo...', true);
            const reader = new FileReader();
            reader.onload = (e) => {
                // Pega apenas as 10 primeiras linhas para preview
                appState[activePageKey].fileContentChunk = e.target.result.split(/[\r\n]+/).slice(0, 10).join('\n');
                autoDetectDelimiterAndSetupPreview();
                showStatus(`Arquivo "${currentFile.name}" carregado.`, false);
                appState[activePageKey].step = 1.5;
                renderCurrentPage();
            };
            reader.readAsText(currentFile, 'UTF-8');
        });

        function autoDetectDelimiterAndSetupPreview() {
            const content = appState[activePageKey].fileContentChunk;
            const commaParse = Papa.parse(content, { delimiter: ',', header: true });
            const semicolonParse = Papa.parse(content, { delimiter: ';', header: true });
            const commaCols = (commaParse.meta.fields || []).length;
            const semicolonCols = (semicolonParse.meta.fields || []).length;
            if (semicolonCols > commaCols && semicolonCols > 1) {
                document.querySelector('input[name="delimiter"][value=";"]').checked = true;
            } else {
                document.querySelector('input[name="delimiter"][value=","]').checked = true;
            }
            updateDataParsePreview();
        }

        ui.delimiterOptions.addEventListener('change', updateDataParsePreview);

        function updateDataParsePreview() {
            const selectedDelimiter = document.querySelector('input[name="delimiter"]:checked').value;
            const content = appState[activePageKey].fileContentChunk;
            const parsed = Papa.parse(content, { delimiter: selectedDelimiter, header: true });
            if (!parsed.data || !parsed.meta.fields || parsed.meta.fields.length <= 1) {
                ui.dataParsePreview.innerHTML = `<p class="text-red-400 p-2">Não foi possível dividir as colunas. Tente o outro separador.</p>`;
                return;
            }
            const previewHeaders = parsed.meta.fields;
            const previewData = parsed.data.slice(0, 4);
            let tableHTML = `<table class="w-full text-xs text-left text-gray-400"><thead class="text-gray-300"><tr class="bg-gray-700">`;
            previewHeaders.forEach(h => { tableHTML += `<th class="p-2 font-semibold border-b border-gray-600">${h}</th>`; });
            tableHTML += `</tr></thead><tbody>`;
            previewData.forEach(row => {
                tableHTML += `<tr class="border-b border-gray-800">`;
                previewHeaders.forEach(h => { tableHTML += `<td class="p-2">${row[h] || ''}</td>`; });
                tableHTML += `</tr>`;
            });
            tableHTML += '</tbody></table>';
            ui.dataParsePreview.innerHTML = tableHTML;
        }

        ui.confirmSeparatorBtn.addEventListener('click', () => {
            const selectedDelimiter = document.querySelector('input[name="delimiter"]:checked').value;
            showStatus('Processando arquivo completo...', true);
            const reader = new FileReader();
            reader.onload = (e) => {
                Papa.parse(e.target.result, {
                    header: true, skipEmptyLines: true, delimiter: selectedDelimiter, dynamicTyping: true,
                    complete: (results) => {
                        appState[activePageKey].headers = results.meta.fields; 
                        appState[activePageKey].rawData = results.data;
                        showStatus('', false);
                        setupColumnMapping();
                        appState[activePageKey].step = 2;
                        renderCurrentPage();
                    }
                });
            };
            reader.readAsText(currentFile, 'UTF-8');
        });

        function setupColumnMapping() {
            const headers = appState[activePageKey].headers;
            const allFields = { date: 'Data*', open: 'Abertura*', high: 'Máxima*', low: 'Mínima*', close: 'Fechamento*' };
            ui.mappingUI.innerHTML = '';
            Object.keys(allFields).forEach(key => {
                const label = allFields[key];
                let selectHTML = `<div class="flex flex-col"><label for="select-${key}" class="block mb-2 text-sm font-medium text-gray-300">${label}</label><select id="select-${key}" data-field="${key}" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5"><option value="">Selecione</option>`;
                let suggestedHeader = findSuggestedHeader(key, headers);
                headers.forEach(header => { selectHTML += `<option value="${header}" ${header === suggestedHeader ? 'selected' : ''}>${header}</option>`; });
                selectHTML += `</select></div>`;
                ui.mappingUI.innerHTML += selectHTML;
            });
        }
        
        ui.confirmMappingBtn.addEventListener('click', () => {
            const mapping = {}, requiredFields = ['date', 'open', 'high', 'low', 'close'];
            let missingFields = [];
            ui.mappingUI.querySelectorAll('select').forEach(select => {
                const field = select.dataset.field, value = select.value;
                mapping[field] = value;
                if (requiredFields.includes(field) && !value) missingFields.push(field);
            });
            if (missingFields.length > 0) {
                showError(ui.step2Error, `Todos os campos marcados com * (Data, Abertura, Máxima, Mínima, Fechamento) são necessários.`); return;
            }
            
            try {
                const rawData = appState[activePageKey].rawData;
                appState[activePageKey].mappedData = rawData.map((row) => {
                    const date = parseDate(row[mapping.date]);
                    if (!date) return null;
                    const close = parseFloat(String(row[mapping.close] || '0').replace(',', '.'));
                    const open = parseFloat(String(row[mapping.open] || '0').replace(',', '.'));
                    const high = parseFloat(String(row[mapping.high] || '0').replace(',', '.'));
                    const low = parseFloat(String(row[mapping.low] || '0').replace(',', '.'));
                    if ([close, open, high, low].some(isNaN)) return null;
                    return { date, open, high, low, close };
                }).filter(d => d !== null).sort((a, b) => a.date - b.date);

                if (appState[activePageKey].mappedData.length < 10) {
                    showError(ui.step2Error, `Dados insuficientes após validação. Pelo menos 10 linhas válidas são necessárias. Verifique o seu arquivo CSV e o mapeamento.`);
                    return;
                }

                hideError(ui.step2Error);
                appState[activePageKey].step = 3;
                renderCurrentPage();
            } catch(e) { showError(ui.step2Error, `Erro ao validar dados: ${e.message}.`); }
        });
        
        function renderEditableTable() {
            const mappedData = appState[activePageKey].mappedData;
            let tableHTML = `<thead class="text-xs text-gray-200 uppercase bg-gray-600 sticky top-0"><tr>
                <th class="px-6 py-3">Data (AAAA-MM-DD)</th><th class="px-6 py-3">Abertura</th>
                <th class="px-6 py-3">Máxima</th><th class="px-6 py-3">Mínima</th>
                <th class="px-6 py-3">Fechamento</th></tr></thead><tbody>`;
            
            mappedData.forEach((row, index) => {
                const dateStr = row.date instanceof Date && !isNaN(row.date) ? row.date.toISOString().split('T')[0] : '';
                tableHTML += `<tr class="data-row hover:bg-gray-700/50">
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="date">${dateStr}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="open">${row.open.toFixed(2)}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="high">${row.high.toFixed(2)}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="low">${row.low.toFixed(2)}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="close">${row.close.toFixed(2)}</td>
                </tr>`;
            });
            ui.dataPreview.innerHTML = tableHTML + '</tbody>';
        }

        ui.addNewRowBtn.addEventListener('click', () => {
            const tbody = ui.dataPreview.querySelector('tbody');
            const lastRow = tbody.querySelector('tr:last-child');
            let newDate = new Date();

            if (lastRow) {
                const lastDateText = lastRow.cells[0].textContent;
                const lastDate = parseDate(lastDateText);
                if (lastDate) {
                    newDate = new Date(lastDate.setDate(lastDate.getDate() + 1));
                }
            }
            
            const newDateStr = newDate.toISOString().split('T')[0];

            const newRow = document.createElement('tr');
            newRow.className = 'data-row hover:bg-gray-700/50';
            newRow.innerHTML = `
                <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="date">${newDateStr}</td>
                <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="open">0.00</td>
                <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="high">0.00</td>
                <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="low">0.00</td>
                <td class="px-6 py-2 border-b border-gray-700" contenteditable="true" data-field="close">0.00</td>
            `;
            tbody.appendChild(newRow);
            newRow.scrollIntoView({ behavior: 'smooth', block: 'end' });
            showStatusMessage('Nova linha adicionada no final. Preencha os valores e rode o backtest novamente.', 'success');
        });


        function updateMappedDataFromTable() {
            const tableRows = ui.dataPreview.querySelectorAll('tbody tr');
            const newMappedData = [];
            let errorFound = false;
            tableRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const dateText = cells[0].textContent.trim();
                const openText = cells[1].textContent.trim();
                const highText = cells[2].textContent.trim();
                const lowText = cells[3].textContent.trim();
                const closeText = cells[4].textContent.trim();
                const date = parseDate(dateText);

                const open = parseFloat(openText.replace(',', '.'));
                const high = parseFloat(highText.replace(',', '.'));
                const low = parseFloat(lowText.replace(',', '.'));
                const close = parseFloat(closeText.replace(',', '.'));

                if (!date || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                    errorFound = true;
                } else {
                    newMappedData.push({ date, open, high, low, close });
                }
            });
             if (errorFound) {
                 showStatusMessage('Foram encontradas linhas com dados inválidos na tabela. Elas foram ignoradas. Verifique a sua tabela.', 'error');
             }

            appState[activePageKey].mappedData = newMappedData.sort((a, b) => a.date - b.date);
        }

        // --- LÓGICA DE BACKTEST E ANÁLISE ---

        function formatCurrency(value, currency = 'BRL') { 
            const locale = currency === 'USD' ? 'en-US' : 'pt-BR';
            return new Intl.NumberFormat(locale, { style: 'currency', currency }).format(value); 
        }

        ui.runBacktestBtn.addEventListener('click', () => {
            updateMappedDataFromTable();
            const smaPeriod = parseInt(ui.smaPeriodInput.value);
            const market = markets[activePageKey];
            const contractSize = parseFloat(ui.contractSizeInput.value);
            const mappedData = appState[activePageKey].mappedData;

            if (mappedData.length < smaPeriod) {
                showStatusMessage(`Dados insuficientes para o período da média móvel. São necessários pelo menos ${smaPeriod} dias de dados.`, 'error');
                return;
            }

            const dataWithSma = calculateSMA(mappedData, smaPeriod);
            const result = generateSignals(dataWithSma, contractSize);
            const trades = result.trades;
            const stats = calculateStats(trades);
            
            displayResults(stats, dataWithSma, trades, market);
            appState[activePageKey].hasBacktestRun = true;
            saveStateToLocalStorage();
            renderCurrentPage();
            ui.resultsSection.scrollIntoView({ behavior: 'smooth' });
        });

        function findSuggestedHeader(fieldKey, headerList) {
            const suggestions = { date: ['date', 'data', 'time'], open: ['open', 'abertura'], high: ['high', 'maxima', 'máxima'], low: ['low', 'minima', 'mínima'], close: ['close', 'last', 'fechamento'] };
            if (!headerList) return '';
            const lowerHeaderList = headerList.map(h => String(h).toLowerCase());
            for (const suggestion of suggestions[fieldKey]) {
                const index = lowerHeaderList.findIndex(h => h.includes(suggestion));
                if (index !== -1) return headerList[index];
            }
            return '';
        }

        function parseDate(dateString) {
            if (!dateString) return null;
            // Adiciona T12:00:00Z para evitar problemas de fuso horário e garantir que a data não mude
            const formats = [
                (ds) => new Date(String(ds).trim() + "T12:00:00Z"), // ISO com time forçado
                (ds) => { const parts = ds.split('/'); if(parts.length === 3 && parts[2].length === 4) return new Date(`${parts[2]}-${parts[1]}-${parts[0]}T12:00:00Z`); return null; }, // DD/MM/YYYY
                (ds) => { const parts = ds.split('-'); if(parts.length === 3 && parts[0].length === 4) return new Date(`${parts[0]}-${parts[1]}-${parts[2]}T12:00:00Z`); return null; }  // YYYY-MM-DD
            ];
            for (const format of formats) {
                try {
                    const d = format(dateString);
                    if (d && !isNaN(d.getTime())) return d;
                } catch(e) { /* ignora erros de formato inválido */ }
            }
            return null;
        }

        function calculateSMA(data, period) { return data.map((row, index, arr) => (index < period - 1) ? { ...row, sma: null } : { ...row, sma: arr.slice(index - period + 1, index + 1).reduce((acc, curr) => acc + curr.close, 0) / period }); }
        
        /**
         * Gera sinais de negociação com base na lógica de Stop-and-Reverse.
         * Alinhado com a especificação: FLAT -> LONG/SHORT (1 contrato), LONG/SHORT -> SHORT/LONG (2 contratos).
         */
        function generateSignals(data, contractSize, initialPosition = 'FLAT') {
            const trades = [];
            let position = initialPosition; 
            let entryPrice = 0; 
            let cumulativeProfit = 0;
            
            if (position !== 'FLAT' && data.length > 0) {
                entryPrice = data[0].open;
            }

            for (let i = 1; i < data.length; i++) {
                const prev = data[i - 1], curr = data[i];
                if (!prev.sma || !curr.sma) continue;

                const crossUp = prev.close < prev.sma && curr.close > curr.sma;
                const crossDown = prev.close > prev.sma && curr.close < curr.sma;

                if (crossUp) { // Sinal de Compra
                    if (position === 'SHORT') { // Reverter de Vendido para Comprado
                        const profit = (entryPrice - curr.close) * contractSize;
                        cumulativeProfit += profit;
                        trades.push({ type: 'BUY', signal: 'REVERSE', contracts: 2, date: curr.date, price: curr.close, profit: profit, equity: cumulativeProfit });
                    } else if (position === 'FLAT') { // Entrar Comprado
                        trades.push({ type: 'BUY', signal: 'ENTRY', contracts: 1, date: curr.date, price: curr.close, profit: 0, equity: cumulativeProfit });
                    }
                    position = 'LONG'; entryPrice = curr.close;
                } else if (crossDown) { // Sinal de Venda
                    if (position === 'LONG') { // Reverter de Comprado para Vendido
                        const profit = (curr.close - entryPrice) * contractSize;
                        cumulativeProfit += profit;
                        trades.push({ type: 'SELL', signal: 'REVERSE', contracts: 2, date: curr.date, price: curr.close, profit: profit, equity: cumulativeProfit });
                    } else if (position === 'FLAT') { // Entrar Vendido
                        trades.push({ type: 'SELL', signal: 'ENTRY', contracts: 1, date: curr.date, price: curr.close, profit: 0, equity: cumulativeProfit });
                    }
                    position = 'SHORT'; entryPrice = curr.close;
                }
            }
            return { trades, finalPosition: position, finalEntryPrice: entryPrice, cumulativeProfit };
        }

        function calculateStats(trades) {
            if (!trades || trades.length === 0) {
                return { totalProfit: 0, winRate: 0, maxDrawdown: 0, totalTrades: 0, equityCurve: [], equityDates: [] };
            }
            const totalProfit = trades[trades.length - 1].equity;
            const totalTrades = trades.length;
            
            // Apenas operações de REVERSE fecham uma posição e geram lucro/prejuízo real para a estatística de acerto.
            const closedTrades = trades.filter(t => t.signal === 'REVERSE');
            const profitableClosedTrades = closedTrades.filter(r => r.profit > 0).length;
            const winRate = closedTrades.length > 0 ? (profitableClosedTrades / closedTrades.length) * 100 : 0;

            const equityCurve = trades.map(t => t.equity);
            const equityDates = trades.map(t => t.date);
            const fullEquityCurve = [0, ...equityCurve];
            let peak = 0;
            let maxDrawdown = 0;
            fullEquityCurve.forEach(equity => {
                if (equity > peak) peak = equity;
                const drawdown = peak - equity;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });
            return { totalProfit, winRate, maxDrawdown, totalTrades, equityCurve, equityDates };
        }
        
        function displayResults(stats, data, trades, market) {
            const currencyFormatter = (value) => formatCurrency(value, market.currency);
            ui.statsContainer.innerHTML = `<div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Lucro/Prejuízo Total</p><p class="text-2xl font-bold ${stats.totalProfit >= 0 ? 'text-green-400' : 'text-red-400'}">${currencyFormatter(stats.totalProfit)}</p></div><div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Taxa de Acerto (Reversões)</p><p class="text-2xl font-bold text-blue-400">${stats.winRate.toFixed(2)}%</p></div><div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Drawdown Máximo</p><p class="text-2xl font-bold text-red-400">${currencyFormatter(stats.maxDrawdown)}</p></div><div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Sinais de Operação</p><p class="text-2xl font-bold text-yellow-400">${stats.totalTrades}</p></div>`;
            displayPriceChart(data, trades); 
            displayEquityChart(stats.equityCurve, stats.equityDates, market.currency, 'equityChart');
        }
        
        function displayPriceChart(data, trades) {
            const ctx = document.getElementById('priceChart').getContext('2d');
            if (priceChart) priceChart.destroy();
            const candlestickData = data.map(d => ({ x: d.date.getTime(), o: d.open, h: d.high, l: d.low, c: d.close }));
            const smaData = data.filter(d => d.sma).map(d => ({ x: d.date.getTime(), y: d.sma }));
            const buySignals = trades.filter(t => t.type === 'BUY').map(t => ({x: t.date.getTime(), y: t.price}));
            const sellSignals = trades.filter(t => t.type === 'SELL').map(t => ({x: t.date.getTime(), y: t.price}));
            priceChart = new Chart(ctx, {
                type: 'candlestick', data: {
                    datasets: [{ label: 'Preço OHLC', data: candlestickData, color: { up: 'rgba(59, 130, 246, 0.8)', down: 'rgba(239, 68, 68, 0.8)', unchanged: 'rgba(107, 114, 128, 0.8)' } },
                                { label: `SMA(${ui.smaPeriodInput.value})`, type: 'line', data: smaData, borderColor: 'rgb(250, 204, 21)', borderWidth: 1.5, pointRadius: 0, },
                                { label: 'Sinais de Compra', type: 'scatter', data: buySignals, backgroundColor: 'rgba(34, 197, 94, 1)', borderColor: 'rgba(255,255,255,0.7)', borderWidth: 1, pointStyle: 'triangle', rotation: 0, radius: 7, hoverRadius: 10, order: -1 },
                                { label: 'Sinais de Venda', type: 'scatter', data: sellSignals, backgroundColor: 'rgba(239, 68, 68, 1)', borderColor: 'rgba(255,255,255,0.7)', borderWidth: 1, pointStyle: 'triangle', rotation: 180, radius: 7, hoverRadius: 10, order: -1 }]
                }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'month' }, ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } } },
                plugins: { legend: { labels: { color: '#d1d5db' } }, tooltip: { mode: 'index', intersect: false }, zoom: { pan: { enabled: true, mode: 'x', threshold: 10, }, zoom: { wheel: { enabled: true, }, drag: { enabled: false, }, pinch: { enabled: true }, mode: 'x', } } } }
            });
        }
        
        function displayEquityChart(equityData, dates, currency, chartId) {
            const chartMap = {
                'equityChart': { chartInstance: equityChart, canvas: document.getElementById('equityChart') },
                'wfaEquityChart': { chartInstance: wfaEquityChart, canvas: document.getElementById('wfaEquityChart') }
            }
            
            let chartObj = chartMap[chartId].chartInstance;
            const equityCtx = chartMap[chartId].canvas.getContext('2d');

            if (chartObj) chartObj.destroy();
            
            if (!dates || dates.length === 0) {
                equityCtx.clearRect(0, 0, equityCtx.canvas.width, equityCtx.canvas.height);
                if (chartId === 'equityChart') equityChart = null; else wfaEquityChart = null;
                return;
            };

            const newChart = new Chart(equityCtx, { 
                type: 'line', 
                data: { 
                    datasets: [{ 
                        label: 'Património Acumulado', 
                        data: dates.map((d, i) => ({x: d.getTime(), y: equityData[i]})), 
                        borderColor: 'rgb(34, 197, 94)', 
                        backgroundColor: 'rgba(34, 197, 94, 0.2)', 
                        borderWidth: 2, 
                        pointRadius: 1, 
                        fill: true, 
                        tension: 0.1 
                    }] 
                }, 
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        x: { type: 'time', time: { unit: 'month' }, ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, 
                        y: { 
                            ticks: { color: '#9ca3af', callback: v => formatCurrency(v, currency) }, 
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }, 
                            title: { display: true, text: `Património (${currency})`, color: '#d1d5db'} 
                        } 
                    }, 
                    plugins: { legend: { labels: { color: '#d1d5db' } } } 
                } 
            });

            if (chartId === 'equityChart') equityChart = newChart; else wfaEquityChart = newChart;
        }
        
        ui.runWfaBtn.addEventListener('click', () => {
            const optimizationPeriods = parseInt(ui.wfaOptimizationPeriods.value);
            const testPeriods = parseInt(ui.wfaTestPeriods.value);
            const mappedData = appState[activePageKey].mappedData;
            
            if(mappedData.length < optimizationPeriods + testPeriods) {
                showError(ui.wfaError, `Dados insuficientes para a configuração Walk-Forward. Necessário pelo menos ${optimizationPeriods + testPeriods} dias.`);
                return;
            }

            hideError(ui.wfaError);
            ui.wfaStatus.innerHTML = `<div class="flex items-center justify-center"><div class="loader mr-2"></div><p>Executando análise Walk-Forward... Isso pode levar alguns momentos.</p></div>`;
            ui.wfaResultsContainer.classList.add('hidden');
            ui.runWfaBtn.disabled = true;

            setTimeout(() => {
                runWalkForwardAnalysis(optimizationPeriods, testPeriods);
                ui.runWfaBtn.disabled = false;
            }, 100);
        });

        function runWalkForwardAnalysis(optimizationPeriods, testPeriods) {
            const market = markets[activePageKey];
            const contractSize = parseFloat(ui.contractSizeInput.value);
            const mappedData = appState[activePageKey].mappedData;
            let allOutOfSampleTrades = [];
            let currentEquity = 0;
            let lastPosition = 'FLAT';
            appState[activePageKey].wfaTradeReturns = [];

            for (let i = 0; (i + optimizationPeriods + testPeriods) <= mappedData.length; i += testPeriods) {
                const optimizationData = mappedData.slice(i, i + optimizationPeriods);
                const testData = mappedData.slice(i + optimizationPeriods, i + optimizationPeriods + testPeriods);
                
                let bestPeriod = -1;
                let bestProfit = -Infinity;

                // Otimização: encontra o melhor período na janela de otimização
                for (let p = 5; p <= 50; p++) {
                    const dataWithSma = calculateSMA(optimizationData, p);
                    const result = generateSignals(dataWithSma, contractSize);
                    if (result.cumulativeProfit > bestProfit) {
                        bestProfit = result.cumulativeProfit;
                        bestPeriod = p;
                    }
                }
                
                // Teste: aplica o melhor período na janela de teste (out-of-sample)
                if (bestPeriod !== -1 && testData.length > 0) {
                    const testDataWithSma = calculateSMA(testData, bestPeriod);
                    // Continua com a última posição da janela anterior para simular continuidade
                    const testResult = generateSignals(testDataWithSma, contractSize, lastPosition);
                    
                    testResult.trades.forEach(trade => {
                        // Salva apenas os lucros das operações para o Monte Carlo
                        if(trade.signal === 'REVERSE') {
                           appState[activePageKey].wfaTradeReturns.push(trade.profit);
                        }
                        currentEquity += trade.profit;
                        allOutOfSampleTrades.push({ ...trade, equity: currentEquity });
                    });

                    lastPosition = testResult.finalPosition;
                }
            }

            ui.wfaStatus.innerHTML = '';
            
            if (allOutOfSampleTrades.length === 0) {
                ui.wfaStatus.innerHTML = `<p class="text-yellow-400">Nenhuma operação foi gerada durante a análise Walk-Forward.</p>`;
                ui.monteCarloSection.classList.add('hidden');
                return;
            }

            const wfaStats = calculateStats(allOutOfSampleTrades);
            const currencyFormatter = (value) => formatCurrency(value, market.currency);

            ui.wfaStatsContainer.innerHTML = `<div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Lucro/Prejuízo Total</p><p class="text-2xl font-bold ${wfaStats.totalProfit >= 0 ? 'text-green-400' : 'text-red-400'}">${currencyFormatter(wfaStats.totalProfit)}</p></div><div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Taxa de Acerto (Reversões)</p><p class="text-2xl font-bold text-blue-400">${wfaStats.winRate.toFixed(2)}%</p></div><div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Drawdown Máximo</p><p class="text-2xl font-bold text-red-400">${currencyFormatter(wfaStats.maxDrawdown)}</p></div><div class="bg-gray-700/50 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Sinais de Operação</p><p class="text-2xl font-bold text-yellow-400">${wfaStats.totalTrades}</p></div>`;
            
            displayEquityChart(wfaStats.equityCurve, wfaStats.equityDates, market.currency, 'wfaEquityChart');

            ui.wfaExplanation.innerHTML = `
                <h3 class="font-semibold text-xl mt-8 mb-4 text-center text-gray-200">O que estes resultados significam?</h3>
                <p class="text-center text-gray-400 mb-6">Esta análise validou o seu <strong>método de adaptação</strong>, e não um único parâmetro "mágico".</p>
                <div class="text-left space-y-4">
                    <p><strong>O que foi Testado:</strong> Em vez de usar um único período de média móvel para todo o histórico, o sistema simulou um trader real. Ele 'aprendeu' com os últimos ${optimizationPeriods} dias para encontrar a melhor média e, em seguida, aplicou-a nos ${testPeriods} dias seguintes (em dados que nunca tinha visto). Este processo foi repetido continuamente.</p>
                    <p><strong>Como Interpretar os Números:</strong> As estatísticas acima (Lucro, Taxa de Acerto, etc.) representam a soma dos resultados obtidos <strong>apenas</strong> nos períodos de teste "fora da amostra". Isto oferece uma visão muito mais realista do que esperar da sua estratégia em condições de mercado em constante mudança.</p>
                    <div>
                        <h4 class="font-semibold text-lg text-green-400">Como Aplicar Para o Futuro? A Sua Estratégia de Negociação:</h4>
                        <ul class="list-disc list-inside mt-2 space-y-2">
                            <li><strong>Passo 1: Defina seu ciclo de reavaliação.</strong> Baseado neste teste, um ciclo de <strong>${testPeriods} dias</strong> foi validado.</li>
                            <li><strong>Passo 2: Otimize para o presente.</strong> Hoje, execute uma otimização usando os dados dos últimos <strong>${optimizationPeriods} dias</strong> para encontrar o período de média móvel ideal para o momento atual. A ferramenta abaixo faz exatamente isso.</li>
                            <li><strong>Passo 3: Opere com o parâmetro encontrado.</strong> Use o período encontrado no Passo 2 para as suas operações durante os próximos <strong>${testPeriods} dias</strong>.</li>
                            <li><strong>Passo 4: Repita.</strong> Após ${testPeriods} dias, volte ao Passo 2 e recomece o ciclo.</li>
                        </ul>
                    </div>
                </div>`;

            appState[activePageKey].hasWfaRun = true;
            saveStateToLocalStorage();
            renderCurrentPage();
            ui.wfaResultsContainer.classList.remove('hidden');
        }

        ui.runCurrentOptimizerBtn.addEventListener('click', () => {
            runCurrentOptimizer();
        });

        function runCurrentOptimizer() {
            const optimizationPeriods = parseInt(ui.wfaOptimizationPeriods.value);
            const mappedData = appState[activePageKey].mappedData;
            if (mappedData.length < optimizationPeriods) {
                showError(ui.currentParameterError, `Dados insuficientes. São necessários pelo menos ${optimizationPeriods} dias.`);
                return;
            }
            hideError(ui.currentParameterError);

            const optimizationData = mappedData.slice(-optimizationPeriods);
            const contractSize = parseFloat(ui.contractSizeInput.value);

            let bestPeriod = -1;
            let bestProfit = -Infinity;

            for (let p = 5; p <= 50; p++) {
                const dataWithSma = calculateSMA(optimizationData, p);
                const result = generateSignals(dataWithSma, contractSize);
                if (result.cumulativeProfit > bestProfit) {
                    bestProfit = result.cumulativeProfit;
                    bestPeriod = p;
                }
            }
            
            if (bestPeriod !== -1) {
                ui.optimizedPeriod.textContent = bestPeriod;
                ui.paramTestDays.textContent = ui.wfaTestPeriods.value;
                ui.paramOptimizationDays.textContent = optimizationPeriods;
                ui.currentParameterResult.classList.remove('hidden');
            } else {
                ui.optimizedPeriod.textContent = "N/A";
                ui.currentParameterResult.classList.remove('hidden');
            }
        }

        ui.runMcBtn.addEventListener('click', () => {
            const wfaTradeReturns = appState[activePageKey].wfaTradeReturns;
            if (!wfaTradeReturns || wfaTradeReturns.length === 0) {
                ui.mcStatus.innerHTML = `<p class="text-red-400">Execute primeiro uma Análise Walk-Forward que gere operações de reversão (com lucro/prejuízo).</p>`;
                return;
            }
            const numSimulations = parseInt(ui.mcSimulations.value);
            const projectionDays = parseInt(ui.mcProjectionDays.value);

            ui.mcStatus.innerHTML = `<div class="flex items-center justify-center"><div class="loader mr-2"></div><p>Executando Simulação de Monte Carlo... Isso pode levar um momento.</p></div>`;
            ui.mcResultsContainer.classList.add('hidden');
            ui.runMcBtn.disabled = true;

            setTimeout(() => {
                runMonteCarloSimulation(numSimulations, projectionDays, wfaTradeReturns);
                ui.runMcBtn.disabled = false;
            }, 100);
        });

        function runMonteCarloSimulation(numSimulations, projectionDays, tradeReturns) {
            const allPaths = [];
            const finalEquities = [];
            const maxDrawdowns = [];

            for (let i = 0; i < numSimulations; i++) {
                const path = [0];
                let currentEquity = 0;
                let peak = 0;
                let maxDrawdown = 0;
                for (let j = 0; j < projectionDays; j++) {
                    // Sorteia um dos resultados das operações do WFA
                    const randomTradeReturn = tradeReturns[Math.floor(Math.random() * tradeReturns.length)];
                    currentEquity += randomTradeReturn;
                    path.push(currentEquity);

                    if (currentEquity > peak) peak = currentEquity;
                    const drawdown = peak - currentEquity;
                    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
                }
                allPaths.push(path);
                finalEquities.push(currentEquity);
                maxDrawdowns.push(maxDrawdown);
            }

            const market = markets[activePageKey];
            const currencyFormatter = (value) => formatCurrency(value, market.currency);
            
            const positiveSimulations = finalEquities.filter(e => e > 0).length;
            const probOfProfit = (positiveSimulations / numSimulations) * 100;
            const avgFinalEquity = finalEquities.reduce((a, b) => a + b, 0) / numSimulations;
            
            finalEquities.sort((a, b) => a - b);
            const medianCase = finalEquities[Math.floor(numSimulations / 2)];

            maxDrawdowns.sort((a, b) => a - b);
            const dd95 = maxDrawdowns[Math.floor(numSimulations * 0.95)];

            ui.mcStatsContainer.innerHTML = `
                <div class="bg-gray-700/50 p-4 rounded-lg text-center"><p class="text-sm text-gray-400">Prob. de Lucro</p><p class="text-2xl font-bold ${probOfProfit > 50 ? 'text-green-400' : 'text-red-400'}">${probOfProfit.toFixed(2)}%</p></div>
                <div class="bg-gray-700/50 p-4 rounded-lg text-center"><p class="text-sm text-gray-400">Lucro Médio Final</p><p class="text-2xl font-bold text-blue-400">${currencyFormatter(avgFinalEquity)}</p></div>
                <div class="bg-gray-700/50 p-4 rounded-lg text-center"><p class="text-sm text-gray-400">Drawdown (95% Conf.)</p><p class="text-2xl font-bold text-red-400">${currencyFormatter(dd95)}</p></div>
                <div class="bg-gray-700/50 p-4 rounded-lg text-center"><p class="text-sm text-gray-400">Resultado Mediano</p><p class="text-2xl font-bold text-yellow-400">${currencyFormatter(medianCase)}</p></div>
            `;
            
                ui.mcExplanation.innerHTML = `
                <h3 class="font-semibold text-xl mt-8 mb-4 text-center text-gray-200">Como usar estas probabilidades?</h3>
                <p class="text-center text-gray-400 mb-6">Esta simulação projeta o "DNA" do seu sistema para o futuro, ajudando a definir expectativas e a gerir o risco.</p>
                <div class="text-left space-y-4">
                    <p><strong>O Gráfico (Cone de Probabilidade):</strong> Cada linha cinzenta é um futuro possível para o seu património, com base nos resultados passados. A linha amarela representa o "caminho mediano" - metade das simulações terminaram melhor e metade pior. O cone mostra a dispersão dos resultados prováveis.</p>
                    <div>
                        <h4 class="font-semibold text-lg text-teal-400">Como Interpretar as Estatísticas para Tomar Decisões:</h4>
                        <ul class="list-disc list-inside mt-2 space-y-2">
                            <li><strong>Probabilidade de Lucro:</strong> Este é o seu "edge" ou vantagem estatística. Se for superior a 50-55%, indica que, a longo prazo, a estratégia tende a ser lucrativa.</li>
                            <li><strong>Drawdown (95% Confiança):</strong> Este é o seu número de <strong>risco</strong>. Prepare o seu capital para suportar uma queda máxima até este valor. Se este número for maior do que o que você está disposto a perder, a estratégia é demasiado arriscada para si.</li>
                            <li><strong>Lucro Médio e Mediano:</strong> Use estes valores como uma expectativa realista de retorno. Eles ajudam a evitar a frustração de esperar resultados extraordinários e a manter a disciplina na estratégia.</li>
                        </ul>
                    </div>
                </div>`;

            displayMonteCarloChart(allPaths, market.currency);
            ui.mcStatus.innerHTML = '';
            appState[activePageKey].hasMcRun = true;
            saveStateToLocalStorage();
            renderCurrentPage();
            ui.mcResultsContainer.classList.remove('hidden');
        }

        function displayMonteCarloChart(paths, currency) {
            if (mcChart) mcChart.destroy();
            const ctx = document.getElementById('mcChart').getContext('2d');
            
            const datasets = paths.slice(0, 100).map(path => ({ // Mostra apenas 100 caminhos para performance
                label: 'Simulação',
                data: path,
                borderColor: 'rgba(107, 114, 128, 0.15)', // cinza mais transparente
                borderWidth: 1.5,
                pointRadius: 0,
                fill: false
            }));

            const sortedPaths = [...paths].sort((a,b) => a[a.length -1] - b[b.length-1]);
            const medianPath = sortedPaths[Math.floor(paths.length / 2)];
            datasets.push({
                label: 'Caminho Mediano',
                data: medianPath,
                borderColor: 'rgb(250, 204, 21)',
                borderWidth: 2,
                pointRadius: 0,
                fill: false,
            });

            mcChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Dias de Projeção', color: '#d1d5db' },
                            ticks: { color: '#9ca3af' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            ticks: { color: '#9ca3af', callback: v => formatCurrency(v, currency) },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            title: { display: true, text: `Património (${currency})`, color: '#d1d5db' }
                        }
                    },
                    plugins: {
                        legend: {
                           labels: {
                                color: '#d1d5db',
                                filter: item => item.text === 'Caminho Mediano'
                           }
                        },
                        tooltip: { enabled: false } // Desabilitado para performance
                    }
                }
            });
        }

        // --- LÓGICA DO MAPA DE PROBABILIDADES ---
        ui.runProbabilityMapBtn.addEventListener('click', async () => {
            ui.probabilityMapStatus.innerHTML = `<div class="flex items-center justify-center"><div class="loader mr-2"></div><p>Iniciando análise profunda... Isso pode levar alguns momentos.</p></div>`;
            ui.probabilityMapContainer.classList.add('hidden');
            ui.runProbabilityMapBtn.disabled = true;

            // Usa setTimeout para garantir que a UI atualize antes do loop pesado
            setTimeout(async () => {
                await runProbabilityMapAnalysis();
                ui.runProbabilityMapBtn.disabled = false;
            }, 100);
        });

        async function runProbabilityMapAnalysis() {
            const mappedData = appState[activePageKey].mappedData;
            const contractSize = parseFloat(ui.contractSizeInput.value);
            const allPeriodsResults = [];
            const startPeriod = 5;
            const endPeriod = 50;

            for (let period = startPeriod; period <= endPeriod; period++) {
                ui.probabilityMapStatus.innerHTML = `<div class="flex items-center justify-center"><div class="loader mr-2"></div><p>Analisando Média de ${period} dias... (${period - startPeriod + 1} de ${endPeriod - startPeriod + 1})</p></div>`;
                
                // Libera a thread da UI para atualizar a mensagem de status
                await new Promise(resolve => setTimeout(resolve, 0)); 

                const dataWithSma = calculateSMA(mappedData, period);
                const result = generateSignals(dataWithSma, contractSize);
                const tradeReturns = result.trades.filter(t=>t.signal === 'REVERSE').map(t => t.profit);
                
                // Pula se não houver operações suficientes para uma amostra estatística
                if (tradeReturns.length < 5) continue; 
                
                const horizons = [7, 14, 21, 30];
                const probs = await runDedicatedMonteCarlo(tradeReturns, 2000, horizons);
                allPeriodsResults.push({ period, probs });
            }
            
            displayProbabilityMap(allPeriodsResults);
            ui.probabilityMapStatus.innerHTML = '';
            appState[activePageKey].hasProbMapRun = true;
            saveStateToLocalStorage();
            renderCurrentPage();
            ui.probabilityMapSection.scrollIntoView({ behavior: 'smooth' });
        }

        async function runDedicatedMonteCarlo(tradeReturns, numSimulations, horizons) {
            const maxHorizon = Math.max(...horizons);
            const results = {};
            horizons.forEach(h => results[h] = 0);

            for(let i=0; i < numSimulations; i++) {
                let currentEquity = 0;
                for (let day = 1; day <= maxHorizon; day++) {
                    const randomReturn = tradeReturns[Math.floor(Math.random() * tradeReturns.length)];
                    currentEquity += randomReturn;
                    // Verifica se o dia atual é um dos horizontes e se o resultado é positivo
                    if (horizons.includes(day) && currentEquity > 0) {
                        results[day]++;
                    }
                }
            }

            const probabilities = {};
            horizons.forEach(h => {
                probabilities[h] = (results[h] / numSimulations) * 100;
            });
            return probabilities;
        }

        function displayProbabilityMap(results) {
            const horizons = [7, 14, 21, 30];
            let theadHTML = '<tr><th class="px-6 py-3">Média Móvel</th>';
            horizons.forEach(h => {
                theadHTML += `<th class="px-6 py-3 text-center">Prob. Lucro (${h} dias)</th>`;
            });
            theadHTML += '</tr>';
            ui.probabilityMapThead.innerHTML = theadHTML;

            let tbodyHTML = '';
            results.sort((a,b) => b.probs[30] - a.probs[30]); // Ordena pelos melhores em 30 dias

            results.forEach(res => {
                tbodyHTML += `<tr class="border-b border-gray-700 hover:bg-gray-700">`;
                tbodyHTML += `<td class="px-6 py-4 font-bold text-white">${res.period} dias</td>`;
                horizons.forEach(h => {
                    const prob = res.probs[h] || 0;
                    const colorClass = prob > 55 ? 'text-green-400' : prob > 50 ? 'text-yellow-400' : 'text-red-400';
                    tbodyHTML += `<td class="px-6 py-4 font-semibold text-center ${colorClass}">${prob.toFixed(2)}%</td>`;
                });
                tbodyHTML += `</tr>`;
            });
            ui.probabilityMapTbody.innerHTML = tbodyHTML;
            
            ui.probabilityMapExplanation.innerHTML = `
                <h3 class="font-semibold text-xl mt-8 mb-4 text-center text-gray-200">Como Usar o Mapa de Probabilidades</h3>
                <div class="text-left space-y-4">
                    <p><strong>O que é esta tabela?</strong> Cada linha representa uma estratégia completa usando um único período de média móvel. Para cada uma, simulamos milhares de futuros possíveis para calcular a probabilidade de a estratégia estar com lucro após 7, 14, 21 e 30 dias de operação. A tabela está ordenada pela robustez a longo prazo (30 dias).</p>
                    <div>
                        <h4 class="font-semibold text-lg text-yellow-400">Como Tomar Decisões com Estes Dados:</h4>
                        <ul class="list-disc list-inside mt-2 space-y-2">
                            <li><strong>Identifique a Elite:</strong> Procure pelos períodos de média móvel (linhas) que mostram as probabilidades mais altas (células em verde) de forma consistente através dos diferentes horizontes de tempo (colunas). Estas são as estratégias estatisticamente mais robustas.</li>
                            <li><strong>Entenda o Perfil de Tempo:</strong> Uma média com alta probabilidade em 7 dias, mas que decai em 30 dias, pode ser melhor para operações de curto prazo. Uma que se mantém ou cresce ao longo do tempo indica maior robustez para manter posições.</li>
                            <li><strong>Confirmação Cruzada:</strong> Compare esta tabela com o resultado do "Qual Parâmetro Usar Agora?". Se o parâmetro otimizado para hoje também estiver entre os que têm as maiores probabilidades neste mapa, a sua confiança para usar esse número deve ser muito maior. Se houver uma grande divergência, justifica-se cautela.</li>
                        </ul>
                    </div>
                </div>`;
            ui.probabilityMapContainer.classList.remove('hidden');
        }

        // --- FUNÇÕES UTILITÁRIAS ---
        function showStatus(message, isLoading) { ui.fileStatus.classList.remove('hidden'); ui.fileStatus.innerHTML = isLoading ? `<div class="flex items-center"><div class="loader mr-2"></div><p>${message}</p></div>` : `<p>${message}</p>`; }
        function showStatusMessage(message, type = 'info') {
            const color = type === 'error' ? 'text-red-400' : type === 'success' ? 'text-green-400' : 'text-blue-400';
            ui.statusMessage.innerHTML = `<p class="${color}">${message}</p>`;
            setTimeout(() => { ui.statusMessage.innerHTML = ''; }, 5000);
        }
        function showError(element, message) { element.textContent = message; element.classList.remove('hidden'); }
        function hideError(element) { element.classList.add('hidden'); }
        
        /**
         * Inicializa a aplicação.
         */
        function initApp() {
            loadStateFromLocalStorage();
            createPageTabs();
            switchPage(activePageKey);
        }
        
        // Inicia a aplicação quando o script é carregado
        initApp();

    </script>
</body>
</html>
