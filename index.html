<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtest de Estratégia de Média Móvel - Boi Gordo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .step-card {
            transition: all 0.3s ease-in-out; opacity: 0.5; pointer-events: none;
            transform: translateY(10px); display: none;
        }
        .step-card.active, .step-card.done { display: block; }
        .step-card.active { opacity: 1; pointer-events: auto; transform: translateY(0); }
        .step-card.done { opacity: 0.7; transform: translateY(0); border-left-color: #22c55e; }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 24px; height: 24px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .chart-container { position: relative; height: 500px; width: 100%; }
        .data-table-container { max-height: 500px; overflow-y: auto; }
        [contenteditable]:focus { outline: 2px solid #3b82f6; background-color: #374151; }
        .gemini-btn {
            background-color: #4f46e5; color: white;
            transition: background-color 0.3s;
        }
        .gemini-btn:hover { background-color: #4338ca; }
    </style>
</head>
<body class="bg-gray-900 text-white p-4 sm:p-6 md:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-3xl sm:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Backtest de Média Móvel para Boi Gordo (BGI)</h1>
            <p class="text-gray-400 mt-2">Plataforma de backtest com análise e simulação por IA.</p>
        </header>

        <div class="space-y-8">
            <!-- Etapa 1: Carregar Arquivo -->
            <div id="step1" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-blue-500 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">1</div>
                    <h2 class="text-2xl font-semibold ml-4">Fonte de Dados</h2>
                </div>
                <p class="text-gray-400 mb-4">Inicie carregando um novo arquivo CSV ou recupere seus dados salvos anteriormente.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div id="uploadArea" class="flex-1">
                        <input type="file" id="csvFile" accept=".csv" class="hidden">
                        <label for="csvFile" class="w-full h-full cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg inline-flex items-center justify-center transition">
                            <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                            <span>Carregar Novo CSV</span>
                        </label>
                    </div>
                    <button id="loadFromStorageBtn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg inline-flex items-center justify-center transition">
                        <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5V4H4zm0 0l5 5m-5 0h5v5H4v-5zm0 0l5-5M9 4v5h5V4H9zm5 5H9v5h5v-5zm0 0l-5-5m0 5l5 5"></path></svg>
                        <span>Carregar Dados Salvos</span>
                    </button>
                </div>
                <div id="fileStatus" class="mt-4 text-gray-300 hidden"></div>
                <div id="step1Error" class="mt-4 text-red-400 hidden p-3 bg-red-900/50 rounded-lg"></div>
            </div>

            <!-- Etapa 1.5: Confirmar Separador -->
            <div id="separatorStep" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-gray-600 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-gray-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">1.5</div>
                    <h2 class="text-2xl font-semibold ml-4">Confirmar Separador de Coluna</h2>
                </div>
                <p class="text-gray-400 mb-4">Escolha o separador para que os dados na tabela abaixo fiquem corretamente divididos em colunas.</p>
                <div id="delimiterOptions" class="flex flex-wrap gap-x-6 gap-y-2 items-center mb-4">
                    <label class="flex items-center space-x-2 text-white cursor-pointer">
                        <input type="radio" name="delimiter" value="," class="form-radio bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-500">
                        <span>Vírgula ( , )</span>
                    </label>
                    <label class="flex items-center space-x-2 text-white cursor-pointer">
                        <input type="radio" name="delimiter" value=";" class="form-radio bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-500">
                        <span>Ponto e vírgula ( ; )</span>
                    </label>
                </div>
                <p class="text-gray-400 mb-2 font-semibold">Pré-visualização dos Dados:</p>
                <div id="dataParsePreview" class="bg-gray-900 p-2 rounded-md overflow-x-auto"></div>
                <button id="confirmSeparatorBtn" class="mt-6 w-full md:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg transition">
                    Confirmar Separador e Continuar
                </button>
            </div>

            <!-- Etapa 2: Mapear Colunas -->
            <div id="step2" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-gray-600 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-gray-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">2</div>
                    <h2 class="text-2xl font-semibold ml-4">Mapear Colunas</h2>
                </div>
                <p class="text-gray-400 mb-6">Associe as colunas detetadas com os campos necessários. <strong class="text-gray-200">Data, Abertura, Máxima, Mínima, e Fechamento</strong> são necessários para o gráfico de candlestick.</p>
                <div id="mappingUI" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4"></div>
                <div id="step2Error" class="mt-4 text-red-400 hidden p-3 bg-red-900/50 rounded-lg"></div>
                <button id="confirmMappingBtn" class="mt-6 w-full md:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg transition">
                    Confirmar Mapeamento e Validar
                </button>
            </div>

            <!-- Etapa 3: Planilha de Dados e Execução -->
            <div id="step3" class="step-card bg-gray-800 p-6 rounded-lg border-l-4 border-gray-600 shadow-lg">
                <div class="flex items-center mb-4">
                    <div class="bg-gray-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold">3</div>
                    <h2 class="text-2xl font-semibold ml-4">Planilha de Dados e Execução</h2>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <label for="smaPeriod" class="block mb-2 text-sm font-medium text-gray-300">Período da Média Móvel</label>
                        <div class="flex items-center gap-2">
                           <input type="number" id="smaPeriod" value="21" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                           <button id="optimizeSmaBtn" title="Otimizar Período com IA" class="gemini-btn p-2.5 rounded-lg">✨</button>
                        </div>
                    </div>
                    <div>
                        <label for="contractSize" class="block mb-2 text-sm font-medium text-gray-300">Tamanho do Contrato (@)</label>
                        <input type="number" id="contractSize" value="330" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                    </div>
                </div>
                 <div class="flex flex-wrap gap-4 mb-4">
                    <button id="addNewRowBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition">Adicionar Nova Linha</button>
                    <button id="saveToStorageBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition">Salvar Alterações</button>
                </div>
                <div id="statusMessage" class="mb-4 text-green-400"></div>
                <h3 class="font-semibold text-lg mb-2 text-gray-300">Dados para o Backtest (Editável)</h3>
                <div class="data-table-container rounded-lg border border-gray-700">
                    <table id="dataPreview" class="min-w-full text-sm text-left text-gray-300 bg-gray-800"></table>
                </div>
                <button id="runBacktestBtn" class="mt-8 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg transition text-lg">
                    Rodar Backtest
                </button>
            </div>
        </div>

        <!-- Seção de Resultados -->
        <div id="resultsSection" class="hidden mt-12">
            <h2 class="text-3xl font-bold text-center mb-8 text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Resultados do Backtest</h2>
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-8">
                <h3 class="font-semibold text-lg mb-2 text-center text-gray-200">Gráfico Interativo de Preços e Sinais</h3>
                <div class="chart-container"><canvas id="priceChart"></canvas></div>
            </div>
            <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                <div id="statsSection" class="bg-gray-800 p-4 rounded-lg shadow-lg">
                    <h3 class="font-semibold text-lg mb-4 text-center text-gray-200">Estatísticas Principais</h3>
                    <div id="statsContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
                </div>
                <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                    <h3 class="font-semibold text-lg mb-2 text-center text-gray-200">Curva de Património</h3>
                    <div class="chart-container" style="height: 400px"><canvas id="equityChart"></canvas></div>
                </div>
            </div>
             <!-- NOVAS FUNCIONALIDADES DE IA -->
             <div id="aiToolsSection" class="mt-12 space-y-8">
                 <div id="aiScenarioSection" class="bg-gray-800 p-6 rounded-lg shadow-lg">
                     <h3 class="font-semibold text-xl mb-4 text-center text-gray-200">Análise de Cenários Futuros com IA</h3>
                     <p class="text-gray-400 text-center mb-6">Simule como a sua estratégia se comportaria em diferentes condições de mercado. A IA irá gerar e anexar 20 dias de dados hipotéticos à sua planilha.</p>
                     <div class="flex flex-wrap justify-center gap-4">
                         <button data-scenario="bull" class="scenario-btn gemini-btn font-bold py-2 px-4 rounded-lg inline-flex items-center">✨ Simular Tendência de Alta</button>
                         <button data-scenario="bear" class="scenario-btn gemini-btn font-bold py-2 px-4 rounded-lg inline-flex items-center">✨ Simular Tendência de Baixa</button>
                         <button data-scenario="sideways" class="scenario-btn gemini-btn font-bold py-2 px-4 rounded-lg inline-flex items-center">✨ Simular Mercado Lateral</button>
                     </div>
                 </div>
                 <div id="aiAnalysisSection" class="text-center">
                      <button id="runAiAnalysisBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg inline-flex items-center justify-center transition">
                         <span class="mr-2">✨</span> Analisar Resultados Atuais com IA
                     </button>
                     <div id="aiResultContainer" class="hidden mt-6 text-left p-6 bg-gray-800 rounded-lg border border-gray-700">
                         <div id="aiLoading" class="flex items-center justify-center"><div class="loader"></div><p class="ml-4">Analisando...</p></div>
                         <div id="aiContent" class="hidden prose prose-invert max-w-none prose-p:text-gray-300 prose-h3:text-green-400"></div>
                         <div id="aiError" class="mt-4 text-red-400 hidden p-3 bg-red-900/50 rounded-lg"></div>
                     </div>
                 </div>
            </div>
        </div>
    </div>

    <script type="module">
        let rawData = [], headers = [], mappedData = [], priceChart = null, equityChart = null, currentFile = null, fileContentChunk = '';
        const ui = {
            loadFromStorageBtn: document.getElementById('loadFromStorageBtn'),
            addNewRowBtn: document.getElementById('addNewRowBtn'),
            saveToStorageBtn: document.getElementById('saveToStorageBtn'),
            statusMessage: document.getElementById('statusMessage'),
            csvFileInput: document.getElementById('csvFile'), 
            fileStatus: document.getElementById('fileStatus'), 
            step1Error: document.getElementById('step1Error'),
            separatorStep: document.getElementById('separatorStep'), 
            delimiterOptions: document.getElementById('delimiterOptions'), 
            dataParsePreview: document.getElementById('dataParsePreview'), 
            confirmSeparatorBtn: document.getElementById('confirmSeparatorBtn'),
            step1: document.getElementById('step1'), 
            step2: document.getElementById('step2'), 
            step3: document.getElementById('step3'),
            mappingUI: document.getElementById('mappingUI'), 
            confirmMappingBtn: document.getElementById('confirmMappingBtn'), 
            step2Error: document.getElementById('step2Error'),
            dataPreview: document.getElementById('dataPreview'), 
            smaPeriodInput: document.getElementById('smaPeriod'), 
            optimizeSmaBtn: document.getElementById('optimizeSmaBtn'),
            runBacktestBtn: document.getElementById('runBacktestBtn'),
            resultsSection: document.getElementById('resultsSection'), 
            statsContainer: document.getElementById('statsContainer'),
            aiToolsSection: document.getElementById('aiToolsSection'),
            aiAnalysisSection: document.getElementById('aiAnalysisSection'), 
            runAiAnalysisBtn: document.getElementById('runAiAnalysisBtn'), 
            aiResultContainer: document.getElementById('aiResultContainer'), 
            aiLoading: document.getElementById('aiLoading'), 
            aiContent: document.getElementById('aiContent'), 
            aiError: document.getElementById('aiError'),
        };

        // --- LÓGICA DE DADOS E PERSISTÊNCIA ---

        ui.loadFromStorageBtn.addEventListener('click', () => {
            const savedData = localStorage.getItem('backtestData');
            if (savedData) {
                try {
                    mappedData = JSON.parse(savedData, (key, value) => {
                        if (key === 'date') return new Date(value);
                        return value;
                    });
                    showStatusMessage(`Dados carregados com sucesso! ${mappedData.length} linhas recuperadas.`);
                    renderEditableTable();
                    activateStep(3);
                } catch (e) {
                    showError(ui.step1Error, "Erro ao carregar dados salvos. O formato pode estar corrompido.");
                }
            } else {
                showError(ui.step1Error, "Nenhum dado salvo foi encontrado no seu navegador.");
            }
        });

        ui.saveToStorageBtn.addEventListener('click', () => {
            updateMappedDataFromTable();
            try {
                localStorage.setItem('backtestData', JSON.stringify(mappedData));
                showStatusMessage('Alterações salvas com sucesso no seu navegador!');
            } catch (e) {
                showStatusMessage('Erro ao salvar dados. O armazenamento pode estar cheio.', true);
            }
        });

        ui.addNewRowBtn.addEventListener('click', () => {
            const newRow = { date: new Date(), open: 0, high: 0, low: 0, close: 0 };
            mappedData.push(newRow);
            renderEditableTable();
            const container = document.querySelector('.data-table-container');
            container.scrollTop = container.scrollHeight;
            showStatusMessage('Nova linha adicionada. Preencha os dados e rode o backtest.', false);
        });

        function showStatusMessage(message, isError = false) {
            ui.statusMessage.textContent = message;
            ui.statusMessage.style.color = isError ? '#f87171' : '#34d399';
            setTimeout(() => { ui.statusMessage.textContent = ''; }, 5000);
        }

        // --- FLUXO DE CARREGAMENTO E MAPEAMENTO ---

        ui.csvFileInput.addEventListener('change', (event) => {
            currentFile = event.target.files[0];
            if (!currentFile) return;
            resetToStep(1);
            showStatus('Lendo amostra do arquivo...', true);
            const reader = new FileReader();
            reader.onload = (e) => {
                fileContentChunk = e.target.result.split(/[\r\n]+/).slice(0, 10).join('\n');
                autoDetectDelimiterAndSetupPreview();
                showStatus(`Arquivo "${currentFile.name}" carregado.`, false);
                activateStep(1.5);
            };
            reader.readAsText(currentFile, 'UTF-8');
        });

        function autoDetectDelimiterAndSetupPreview() {
            const commaParse = Papa.parse(fileContentChunk, { delimiter: ',', header: true });
            const semicolonParse = Papa.parse(fileContentChunk, { delimiter: ';', header: true });
            const commaCols = (commaParse.meta.fields || []).length;
            const semicolonCols = (semicolonParse.meta.fields || []).length;
            if (semicolonCols > commaCols && semicolonCols > 1) {
                document.querySelector('input[name="delimiter"][value=";"]').checked = true;
            } else {
                document.querySelector('input[name="delimiter"][value=","]').checked = true;
            }
            updateDataParsePreview();
        }

        ui.delimiterOptions.addEventListener('change', updateDataParsePreview);

        function updateDataParsePreview() {
            const selectedDelimiter = document.querySelector('input[name="delimiter"]:checked').value;
            const parsed = Papa.parse(fileContentChunk, { delimiter: selectedDelimiter, header: true });
            if (!parsed.data || !parsed.meta.fields || parsed.meta.fields.length <= 1) {
                ui.dataParsePreview.innerHTML = `<p class="text-red-400 p-2">Não foi possível dividir as colunas. Tente o outro separador.</p>`;
                return;
            }
            const previewHeaders = parsed.meta.fields;
            const previewData = parsed.data.slice(0, 4);
            let tableHTML = `<table class="w-full text-xs text-left text-gray-400"><thead class="text-gray-300"><tr class="bg-gray-700">`;
            previewHeaders.forEach(h => { tableHTML += `<th class="p-2 font-semibold border-b border-gray-600">${h}</th>`; });
            tableHTML += `</tr></thead><tbody>`;
            previewData.forEach(row => {
                tableHTML += `<tr class="border-b border-gray-800">`;
                previewHeaders.forEach(h => { tableHTML += `<td class="p-2">${row[h] || ''}</td>`; });
                tableHTML += `</tr>`;
            });
            tableHTML += '</tbody></table>';
            ui.dataParsePreview.innerHTML = tableHTML;
        }

        ui.confirmSeparatorBtn.addEventListener('click', () => {
            const selectedDelimiter = document.querySelector('input[name="delimiter"]:checked').value;
            showStatus('Processando arquivo completo...', true);
            const reader = new FileReader();
            reader.onload = (e) => {
                Papa.parse(e.target.result, {
                    header: true, skipEmptyLines: true, delimiter: selectedDelimiter, dynamicTyping: true,
                    complete: (results) => {
                        headers = results.meta.fields; rawData = results.data;
                        showStatus('', false);
                        setupColumnMapping();
                        activateStep(2);
                    }
                });
            };
            reader.readAsText(currentFile, 'UTF-8');
        });

        function setupColumnMapping() {
            const allFields = { date: 'Data*', open: 'Abertura*', high: 'Máxima*', low: 'Mínima*', close: 'Fechamento*' };
            ui.mappingUI.innerHTML = '';
            Object.keys(allFields).forEach(key => {
                const label = allFields[key];
                let selectHTML = `<div class="flex flex-col"><label for="select-${key}" class="block mb-2 text-sm font-medium text-gray-300">${label}</label><select id="select-${key}" data-field="${key}" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5"><option value="">Selecione</option>`;
                let suggestedHeader = findSuggestedHeader(key, headers);
                headers.forEach(header => { selectHTML += `<option value="${header}" ${header === suggestedHeader ? 'selected' : ''}>${header}</option>`; });
                selectHTML += `</select></div>`;
                ui.mappingUI.innerHTML += selectHTML;
            });
        }
        
        ui.confirmMappingBtn.addEventListener('click', () => {
            const mapping = {}, requiredFields = ['date', 'open', 'high', 'low', 'close'];
            let missingFields = [];
            ui.mappingUI.querySelectorAll('select').forEach(select => {
                const field = select.dataset.field, value = select.value;
                mapping[field] = value;
                if (requiredFields.includes(field) && !value) missingFields.push(field);
            });
            if (missingFields.length > 0) {
                showError(ui.step2Error, `Todos os campos (Data, Abertura, Máxima, Mínima, Fechamento) são necessários.`); return;
            }
            
            try {
                mappedData = rawData.map((row) => {
                    const date = parseDate(row[mapping.date]);
                    if (!date) return null;
                    const close = parseFloat(String(row[mapping.close] || '0').replace(',', '.'));
                    const open = parseFloat(String(row[mapping.open] || '0').replace(',', '.'));
                    const high = parseFloat(String(row[mapping.high] || '0').replace(',', '.'));
                    const low = parseFloat(String(row[mapping.low] || '0').replace(',', '.'));
                    if ([close, open, high, low].some(isNaN)) return null;
                    return { date, open, high, low, close };
                }).filter(d => d !== null).sort((a, b) => a.date - b.date);

                hideError(ui.step2Error);
                renderEditableTable();
                activateStep(3);
            } catch(e) { showError(ui.step2Error, `Erro ao validar dados: ${e.message}.`); }
        });
        
        // --- FUNÇÕES DE BACKTEST E VISUALIZAÇÃO ---

        function renderEditableTable() {
            let tableHTML = `<thead class="text-xs text-gray-200 uppercase bg-gray-600 sticky top-0"><tr>
                <th class="px-6 py-3">Data (AAAA-MM-DD)</th><th class="px-6 py-3">Abertura</th>
                <th class="px-6 py-3">Máxima</th><th class="px-6 py-3">Mínima</th>
                <th class="px-6 py-3">Fechamento</th></tr></thead><tbody>`;
            
            mappedData.forEach((row, index) => {
                const dateStr = row.date instanceof Date && !isNaN(row.date) ? row.date.toISOString().split('T')[0] : '';
                tableHTML += `<tr class="data-row">
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true">${dateStr}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true">${row.open.toFixed(2)}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true">${row.high.toFixed(2)}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true">${row.low.toFixed(2)}</td>
                    <td class="px-6 py-2 border-b border-gray-700" contenteditable="true">${row.close.toFixed(2)}</td>
                </tr>`;
            });
            ui.dataPreview.innerHTML = tableHTML + '</tbody>';
        }

        function updateMappedDataFromTable() {
            const tableRows = ui.dataPreview.querySelectorAll('tbody tr');
            const newMappedData = [];
            tableRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const dateText = cells[0].textContent.trim();
                const openText = cells[1].textContent.trim();
                const highText = cells[2].textContent.trim();
                const lowText = cells[3].textContent.trim();
                const closeText = cells[4].textContent.trim();
                const date = parseDate(dateText);
                if (date) {
                    newMappedData.push({
                        date: date,
                        open: parseFloat(openText.replace(',', '.')) || 0,
                        high: parseFloat(highText.replace(',', '.')) || 0,
                        low: parseFloat(lowText.replace(',', '.')) || 0,
                        close: parseFloat(closeText.replace(',', '.')) || 0,
                    });
                }
            });
            mappedData = newMappedData.sort((a, b) => a.date - b.date);
        }

        ui.runBacktestBtn.addEventListener('click', () => {
            updateMappedDataFromTable();
            const smaPeriod = parseInt(ui.smaPeriodInput.value);
            const contractSize = parseFloat(document.getElementById('contractSize').value);
            const dataWithSma = calculateSMA(mappedData, smaPeriod);
            const trades = generateSignals(dataWithSma, contractSize);
            const stats = calculateStats(trades);
            displayResults(stats, dataWithSma, trades);
        });

        // --- FUNÇÕES DE IA (GEMINI API) ---
        
        async function callGeminiAPI(prompt, isJson = false) {
            // --- INÍCIO DA CORREÇÃO: Chave de API inserida ---
            const apiKey = "AIzaSyDaPmVKULxwIEyoV345gPznnjMPesUbekY"; 
            // --- FIM DA CORREÇÃO ---
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }]
            };

            if (isJson) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "o": { "type": "NUMBER" },
                                "h": { "type": "NUMBER" },
                                "l": { "type": "NUMBER" },
                                "c": { "type": "NUMBER" },
                            },
                            required: ["o", "h", "l", "c"]
                        }
                    }
                };
            }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorBody}`);
                }
                
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    throw new Error("Resposta da IA inválida ou vazia.");
                }
            } catch (error) {
                console.error("Erro na chamada da API Gemini:", error);
                throw error;
            }
        }

        ui.optimizeSmaBtn.addEventListener('click', async () => {
            if (mappedData.length < 20) {
                showStatusMessage("São necessários pelo menos 20 dias de dados para otimizar.", true);
                return;
            }
            showStatusMessage("✨ IA a otimizar o período da média móvel...");
            ui.optimizeSmaBtn.disabled = true;

            const last30Closes = mappedData.slice(-30).map(d => d.close);
            
            const prompt = `Para uma estratégia de trading de cruzamento de média móvel num ativo de commodity (boi gordo), e considerando os preços de fecho recentes e uma volatilidade moderada, sugira um único número inteiro para o período da média móvel que equilibre bem a capacidade de resposta a novas tendências sem ser excessivamente sensível a pequenas flutuações. Responda apenas com o número. Exemplo: 21`;

            try {
                const result = await callGeminiAPI(prompt);
                const suggestedPeriod = parseInt(result.match(/\d+/)[0]);
                if (suggestedPeriod) {
                    ui.smaPeriodInput.value = suggestedPeriod;
                    showStatusMessage(`✨ IA sugere o período ${suggestedPeriod}. Execute o backtest para ver os resultados.`);
                }
            } catch (error) {
                showStatusMessage(`Erro ao otimizar: ${error.message}`, true);
            } finally {
                ui.optimizeSmaBtn.disabled = false;
            }
        });
        
        document.querySelectorAll('.scenario-btn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const scenario = e.target.dataset.scenario;
                if (mappedData.length < 10) {
                    showStatusMessage("São necessários pelo menos 10 dias de dados para gerar um cenário.", true);
                    return;
                }
                
                let scenarioText;
                if(scenario === 'bull') scenarioText = 'forte tendência de alta';
                if(scenario === 'bear') scenarioText = 'forte tendência de baixa';
                if(scenario === 'sideways') scenarioText = 'mercado lateral com volatilidade moderada';

                showStatusMessage(`✨ IA a gerar um cenário de ${scenarioText}...`);
                e.target.disabled = true;

                const last10Data = mappedData.slice(-10);
                const lastDataString = last10Data.map(d => `Data: ${d.date.toISOString().split('T')[0]}, Fecho: ${d.close.toFixed(2)}`).join('\n');
                const lastClose = last10Data[last10Data.length - 1].close;

                const prompt = `Com base nos últimos 10 dias de dados de uma commodity, cujo último preço de fecho foi ${lastClose.toFixed(2)}, gere 20 dias de dados OHLC plausíveis que sigam um(a) ${scenarioText}. O preço de abertura do primeiro dia novo deve ser próximo de ${lastClose.toFixed(2)}. Mantenha os valores de alta (h) acima do fecho (c) e abertura (o), e os valores de baixa (l) abaixo. Os valores devem ser realistas.

Dados recentes para contexto:
${lastDataString}`;
                
                try {
                    const resultText = await callGeminiAPI(prompt, true);
                    const newOhlcData = JSON.parse(resultText);

                    let lastDate = new Date(mappedData[mappedData.length - 1].date);
                    newOhlcData.forEach(day => {
                        lastDate.setDate(lastDate.getDate() + 1);
                        if(lastDate.getDay() === 0) lastDate.setDate(lastDate.getDate() + 1);
                        if(lastDate.getDay() === 6) lastDate.setDate(lastDate.getDate() + 2);

                        mappedData.push({
                            date: new Date(lastDate),
                            open: day.o,
                            high: day.h,
                            low: day.l,
                            close: day.c
                        });
                    });
                    
                    renderEditableTable();
                    showStatusMessage(`✨ Cenário de ${scenarioText} adicionado! Execute o backtest para ver os resultados.`);
                    ui.runBacktestBtn.click();

                } catch(error) {
                    showStatusMessage(`Erro ao gerar cenário: ${error.message}`, true);
                } finally {
                    e.target.disabled = false;
                }
            });
        });

        // --- FUNÇÕES CORE (cálculos, etc) ---

        function findSuggestedHeader(fieldKey, headerList) {
            const suggestions = { date: ['date', 'data', 'time'], open: ['open', 'abertura'], high: ['high', 'maxima', 'máxima'], low: ['low', 'minima', 'mínima'], close: ['close', 'last', 'fechamento'] };
            if (!headerList) return '';
            const lowerHeaderList = headerList.map(h => String(h).toLowerCase());
            for (const suggestion of suggestions[fieldKey]) {
                const index = lowerHeaderList.findIndex(h => h.includes(suggestion));
                if (index !== -1) return headerList[index];
            }
            return '';
        }

        function parseDate(dateString) {
            if (!dateString) return null;
            const d = new Date(String(dateString).trim() + "T12:00:00Z");
            return isNaN(d.getTime()) ? null : d;
        }

        function calculateSMA(data, period) { return data.map((row, index, arr) => (index < period - 1) ? { ...row, sma: null } : { ...row, sma: arr.slice(index - period + 1, index + 1).reduce((acc, curr) => acc + curr.close, 0) / period }); }
        
        function generateSignals(data, contractSize) {
            const trades = [];
            let position = 'FLAT'; let entryPrice = 0; let cumulativeProfit = 0;
            for (let i = 1; i < data.length; i++) {
                const prev = data[i - 1], curr = data[i];
                if (!prev.sma || !curr.sma) continue;
                const crossUp = prev.close < prev.sma && curr.close > curr.sma;
                const crossDown = prev.close > prev.sma && curr.close < curr.sma;
                if (crossUp) {
                    if (position === 'SHORT') {
                        const profit = (entryPrice - curr.close) * contractSize;
                        cumulativeProfit += profit;
                        trades.push({ type: 'BUY', signal: 'REVERSE', date: curr.date, price: curr.close, profit: profit, equity: cumulativeProfit });
                    } else if (position === 'FLAT') {
                        trades.push({ type: 'BUY', signal: 'ENTRY', date: curr.date, price: curr.close, profit: 0, equity: cumulativeProfit });
                    }
                    position = 'LONG'; entryPrice = curr.close;
                } else if (crossDown) {
                    if (position === 'LONG') {
                        const profit = (curr.close - entryPrice) * contractSize;
                        cumulativeProfit += profit;
                        trades.push({ type: 'SELL', signal: 'REVERSE', date: curr.date, price: curr.close, profit: profit, equity: cumulativeProfit });
                    } else if (position === 'FLAT') {
                        trades.push({ type: 'SELL', signal: 'ENTRY', date: curr.date, price: curr.close, profit: 0, equity: cumulativeProfit });
                    }
                    position = 'SHORT'; entryPrice = curr.close;
                }
            }
            return trades;
        }

        function calculateStats(trades) {
            if (trades.length === 0) return { totalProfit: 0, winRate: 0, maxDrawdown: 0, totalTrades: 0, equityCurve: [], equityDates: [] };
            const closedTrades = trades.filter(t => t.signal === 'REVERSE');
            if (closedTrades.length === 0) return { totalProfit: 0, winRate: 0, maxDrawdown: 0, totalTrades: trades.length, equityCurve: [], equityDates: [] };
            const results = closedTrades.map(t => t.profit);
            const totalProfit = results.reduce((a, b) => a + b, 0);
            const wins = results.filter(r => r > 0).length;
            const totalTrades = trades.length; 
            const winRate = results.length > 0 ? (wins / results.length) * 100 : 0;
            const equityCurve = closedTrades.map(t => t.equity);
            const equityDates = closedTrades.map(t => t.date);
            const fullEquityCurve = [0, ...equityCurve];
            let peak = 0, maxDrawdown = 0;
            fullEquityCurve.forEach(equity => { if (equity > peak) peak = equity; const drawdown = peak - equity; if (drawdown > maxDrawdown) maxDrawdown = drawdown; });
            return { totalProfit, winRate, maxDrawdown, totalTrades, equityCurve, equityDates };
        }

        function displayResults(stats, data, trades) {
            ui.statsContainer.innerHTML = `<div class="bg-gray-800 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Lucro/Prejuízo Total</p><p class="text-2xl font-bold ${stats.totalProfit >= 0 ? 'text-green-400' : 'text-red-400'}">${formatCurrency(stats.totalProfit)}</p></div><div class="bg-gray-800 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Taxa de Acerto</p><p class="text-2xl font-bold text-blue-400">${stats.winRate.toFixed(2)}%</p></div><div class="bg-gray-800 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Drawdown Máximo</p><p class="text-2xl font-bold text-red-400">${formatCurrency(stats.maxDrawdown)}</p></div><div class="bg-gray-800 p-4 rounded-lg text-center shadow-lg"><p class="text-sm text-gray-400">Sinais de Operação</p><p class="text-2xl font-bold text-yellow-400">${stats.totalTrades}</p></div>`;
            displayPriceChart(data, trades); 
            displayEquityChart(stats.equityCurve, stats.equityDates);
            ui.resultsSection.classList.remove('hidden'); 
            ui.resultsSection.scrollIntoView({ behavior: 'smooth' });
        }
        
        function displayPriceChart(data, trades) {
            const ctx = document.getElementById('priceChart').getContext('2d');
            if (priceChart) priceChart.destroy();
            const candlestickData = data.map(d => ({ x: d.date.getTime(), o: d.open, h: d.high, l: d.low, c: d.close }));
            const smaData = data.map(d => ({ x: d.date.getTime(), y: d.sma }));
            const buySignals = trades.filter(t => t.type === 'BUY').map(t => ({x: t.date.getTime(), y: t.price}));
            const sellSignals = trades.filter(t => t.type === 'SELL').map(t => ({x: t.date.getTime(), y: t.price}));
            priceChart = new Chart(ctx, {
                type: 'candlestick', data: {
                    datasets: [{ label: 'Preço OHLC', data: candlestickData, color: { up: 'rgba(59, 130, 246, 0.8)', down: 'rgba(239, 68, 68, 0.8)', unchanged: 'rgba(107, 114, 128, 0.8)' } },
                               { label: `SMA(${ui.smaPeriodInput.value})`, type: 'line', data: smaData, borderColor: 'rgb(250, 204, 21)', borderWidth: 1.5, pointRadius: 0, },
                               { label: 'Sinais de Compra', type: 'scatter', data: buySignals, backgroundColor: 'rgba(34, 197, 94, 1)', borderColor: 'rgba(255,255,255,0.7)', borderWidth: 1, pointStyle: 'triangle', rotation: 0, radius: 7, hoverRadius: 10, order: -1 },
                               { label: 'Sinais de Venda', type: 'scatter', data: sellSignals, backgroundColor: 'rgba(239, 68, 68, 1)', borderColor: 'rgba(255,255,255,0.7)', borderWidth: 1, pointStyle: 'triangle', rotation: 180, radius: 7, hoverRadius: 10, order: -1 }]
                }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'month' }, ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } } },
                plugins: { legend: { labels: { color: '#d1d5db' } }, tooltip: { mode: 'index', intersect: false }, zoom: { pan: { enabled: true, mode: 'x', threshold: 10, }, zoom: { wheel: { enabled: true, }, drag: { enabled: false, }, pinch: { enabled: true }, mode: 'x', } } } }
            });
        }
        
        function displayEquityChart(equityData, dates) {
            if (equityChart) equityChart.destroy();
            if (!dates || dates.length === 0) {
                const equityCtx = document.getElementById('equityChart').getContext('2d');
                equityCtx.clearRect(0, 0, equityCtx.canvas.width, equityCtx.canvas.height);
                return;
            };
            equityChart = new Chart(document.getElementById('equityChart').getContext('2d'), { type: 'line', data: { datasets: [{ label: 'Património Acumulado', data: dates.map((d, i) => ({x: d.getTime(), y: equityData[i]})), borderColor: 'rgb(34, 197, 94)', backgroundColor: 'rgba(34, 197, 94, 0.2)', borderWidth: 2, pointRadius: 1, fill: true, tension: 0.1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'month' }, ticks: { color: '#9ca3af' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { ticks: { color: '#9ca3af', callback: v => formatCurrency(v) }, grid: { color: 'rgba(255, 255, 255, 0.1)' }, title: { display: true, text: 'Património (R$)', color: '#d1d5db'} } }, plugins: { legend: { labels: { color: '#d1d5db' } } } } });
        }
        
        ui.runAiAnalysisBtn.addEventListener('click', async () => {
            ui.aiResultContainer.classList.remove('hidden'); ui.aiContent.classList.add('hidden'); ui.aiLoading.classList.remove('hidden'); ui.aiError.classList.add('hidden');
            const statsText = ui.statsContainer.innerText, smaPeriod = ui.smaPeriodInput.value;
            const prompt = `Como um especialista em análise quantitativa e commodities agrícolas, analise os seguintes resultados de um backtest para o contrato futuro de Boi Gordo (BGI) na B3. A estratégia utilizada foi um cruzamento de média móvel com reversão de posição (stop-and-reverse).\n\n**Estratégia:**\n- Ativo: Contrato Futuro de Boi Gordo (BGI)\n- Sinal de Compra/Reversão Long: Preço de fecho cruza acima da Média Móvel Simples (SMA).\n- Sinal de Venda/Reversão Short: Preço de fecho cruza abaixo da Média Móvel Simples (SMA).\n- Período da SMA: ${smaPeriod} dias.\n\n**Resultados do Backtest:**\n${statsText}\n\n**Sua Tarefa:**\nForneça uma análise crítica e construtiva em Markdown. Siga esta estrutura:\n\n### Análise dos Resultados\nComente o desempenho geral.\n\n### Pontos Fortes\n\n### Pontos Fracos e Riscos\n\n### Sugestões de Otimização\n\nSeja direto, prático e evite jargões excessivamente técnicos.`;
             try {
                const text = await callGeminiAPI(prompt);
                ui.aiContent.innerHTML = text.replace(/^### (.*$)/gim, '<h3>$1</h3>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/^\* (.*$)/gim, '<li>$1</li>').replace(/(<\/li>\s*<li>)/g, '</li><li>').replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>').replace(/\n/g, '<br>');
                ui.aiContent.classList.remove('hidden');
            } catch (error) {
                ui.aiError.textContent = `Falha ao obter análise da IA: ${error.message}.`; ui.aiError.classList.remove('hidden');
            } finally {
                ui.aiLoading.classList.add('hidden');
            }
        });

        function showStatus(message, isLoading) { ui.fileStatus.classList.remove('hidden'); ui.fileStatus.innerHTML = isLoading ? `<div class="flex items-center"><div class="loader mr-2"></div><p>${message}</p></div>` : `<p>${message}</p>`; }
        function showError(element, message) { element.textContent = message; element.classList.remove('hidden'); }
        function hideError(element) { element.classList.add('hidden'); }
        function activateStep(stepNumber) {
            const allSteps = [ui.step1, ui.separatorStep, ui.step2, ui.step3];
            allSteps.forEach(s => s.classList.remove('active', 'done'));
            const stepMap = { '1': ui.step1, '1.5': ui.separatorStep, '2': ui.step2, '3': ui.step3 };
            if (stepNumber > 1) { ui.step1.classList.add('done'); ui.step1.querySelector('.flex > div').classList.replace('bg-blue-500', 'bg-green-500'); }
            if (stepNumber > 1.5) { ui.separatorStep.classList.add('done'); ui.separatorStep.querySelector('.flex > div').classList.replace('bg-gray-600', 'bg-green-500');}
            if (stepNumber > 2) { ui.step2.classList.add('done'); ui.step2.querySelector('.flex > div').classList.replace('bg-gray-600', 'bg-green-500');}
            if (stepMap[stepNumber]) {
                const currentStep = stepMap[stepNumber];
                currentStep.classList.add('active');
                const iconDiv = currentStep.querySelector('.flex > div');
                if(iconDiv) iconDiv.classList.replace('bg-gray-600', 'bg-blue-500');
                currentStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        function resetToStep(stepNumber) {
            ui.resultsSection.classList.add('hidden'); hideError(ui.step1Error); hideError(ui.step2Error);
            activateStep(stepNumber);
        }
        function formatCurrency(value) { return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value); }

        resetToStep(1);
    </script>
</body>
</html>
